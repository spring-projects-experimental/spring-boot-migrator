<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!--
  ~ Copyright 2021 - 2022-2022 the original author or authors.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      https://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<xsd:schema xmlns="http://www.mulesoft.org/schema/mule/core"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:spring="http://www.springframework.org/schema/beans"
            xmlns:spring-context="http://www.springframework.org/schema/context"
            targetNamespace="http://www.mulesoft.org/schema/mule/core"
            attributeFormDefault="unqualified"
            elementFormDefault="qualified">

    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:import namespace="http://www.springframework.org/schema/beans"
                schemaLocation="./spring-beans-4.3.xsd"/>
    <xsd:import namespace="http://www.springframework.org/schema/context"
                schemaLocation="./spring-context-4.3.xsd"/>

    <!--==============================================================-->
    <!--   Structure                                                  -->
    <!--==============================================================-->

    <!-- This defines the structure in abstract terms (except for a few simple/unique things like
         global properties).  We then provide some implementations below.  Other modules
         can provide other implementations. -->

    <xsd:complexType name="annotationsType">
        <xsd:sequence>
            <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="annotatedType" abstract="true">
        <xsd:sequence>
            <xsd:element name="annotations" type="annotationsType" minOccurs="0"/>
        </xsd:sequence>
        <xsd:anyAttribute namespace="##other" processContents="lax">
            <xsd:annotation>
                <xsd:documentation>
                    Allow any third-parties to annotate these elements with global attributes.  All types for
                    top-level elements must extend this.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:anyAttribute>
    </xsd:complexType>

    <xsd:complexType name="annotatedMixedContentType" abstract="true" mixed="true">
        <xsd:sequence>
            <xsd:element name="annotations" type="annotationsType" minOccurs="0"/>
        </xsd:sequence>
        <xsd:anyAttribute namespace="##other" processContents="lax">
            <xsd:annotation>
                <xsd:documentation>
                    Allow any third-parties to annotate these elements with global attributes
                </xsd:documentation>
            </xsd:annotation>
        </xsd:anyAttribute>
    </xsd:complexType>

    <xsd:element name="mule" type="muleType">
        <xsd:annotation>
            <xsd:documentation>
                Either the root element of a Mule configuration, or a "top-level" element in a Spring configuration that contains further Mule elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="muleType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:sequence>
                    <xsd:element name="description" type="descriptionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Holds any kind of documentation that accompanies this configuration file. It is intended to be "human readable" only and is not used by the system.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:group ref="springRootElements"/>
                        <xsd:group ref="muleRootElements"/>
                    </xsd:choice>
                </xsd:sequence>
                <xsd:attribute name="version" type ="xsd:string"/>

            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:group name="springRootElements">
        <xsd:choice>
            <xsd:element ref="spring:beans">
                <xsd:annotation>
                    <xsd:documentation>
                        Allows the embedding of any Spring elements.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="spring:bean">
                <xsd:annotation>
                    <xsd:documentation>
                        Allows Spring beans to be defined alongside Mule elements.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="spring-context:property-placeholder">
                <xsd:annotation>
                    <xsd:documentation>
                        Allows Spring property placeholders to be configured directly in the Mule configuration file.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="spring:ref">
                <xsd:annotation>
                    <xsd:documentation>
                        Allows to reference Spring beans alongside Mule elements.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:choice>
    </xsd:group>

    <xsd:group name="muleRootElements">
        <xsd:choice>
            <xsd:element ref="global-property"/>
            <xsd:element ref="configuration"/>
            <xsd:element ref="notifications"/>
            <xsd:element ref="abstract-extension"/>
            <xsd:element ref="abstract-shared-extension"/>
            <xsd:element ref="abstract-mixed-content-extension"/>
            <xsd:element ref="abstract-agent"/>
            <xsd:element ref="abstract-security-manager"/>
            <xsd:element ref="abstract-transaction-manager"/>
            <xsd:element ref="abstract-shared-transaction-manager"/>
            <xsd:element ref="abstract-connector"/>
            <xsd:element ref="abstract-shared-connector"/>
            <xsd:element ref="abstract-global-endpoint"/>
            <xsd:element ref="abstract-exception-strategy"/>
            <xsd:element ref="abstract-flow-construct" />
            <xsd:element ref="flow" />
            <xsd:element ref="sub-flow" />
            <xsd:element ref="abstract-model"/>
            <xsd:element ref="abstract-interceptor-stack"/>
            <xsd:element ref="abstract-filter"/>
            <xsd:element ref="abstract-transformer"/>
            <xsd:element ref="processor-chain"/>
            <xsd:element ref="custom-processor"/>
            <xsd:element ref="abstract-empty-processor"/>
            <xsd:element ref="invoke"/>
            <xsd:element ref="set-payload"/>
            <xsd:element ref="abstract-global-intercepting-message-processor"/>
            <xsd:element ref="custom-queue-store" minOccurs="0" maxOccurs="unbounded"/>
            <xsd:element ref="abstract-processing-strategy" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:choice>
    </xsd:group>

    <xsd:complexType name="descriptionType">
        <xsd:complexContent mixed="true">
            <xsd:extension base="xsd:anyType"/>
        </xsd:complexContent>
    </xsd:complexType>

            <xsd:element name="global-property" type="globalPropertyType">
                <xsd:annotation>
                    <xsd:documentation>
                        A global property is a named string. It can be inserted in most attribute values using standard (ant-style) Spring placeholders.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>

            <xsd:element name="configuration" type="configurationType">
                <xsd:annotation>
                    <xsd:documentation>
                        Specifies defaults and general settings for the Mule instance.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>

            <xsd:element name="notifications" type="notificationManagerType">
                <xsd:annotation>
                    <xsd:documentation>
                        Registers listeners for notifications and associates interfaces with particular events.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>

    <xsd:element name="abstract-shared-extension" abstract="true" type="abstractExtensionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for arbitrary extensions as children of the 'mule' element or 'mule-domain'. Other transports and modules can extend this if they need to add global elements to the configuration (but consider the more specific elements like abstract-connector first).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="abstract-extension" abstract="true" type="abstractExtensionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for arbitrary extensions as children of the 'mule' element. Other transports and modules can extend this if they need to add global elements to the configuration (but consider the more specific elements like abstract-connector first).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractExtensionType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-mixed-content-extension" abstract="true" type="abstractMixedContentExtensionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for arbitrary extensions as children of the 'mule' element. Other transports and modules can extend this if they need to add global elements with mixed content to the configuration (but consider the more specific elements like abstract-connector first).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractMixedContentExtensionType">
        <xsd:complexContent mixed="true">
            <xsd:extension base="annotatedMixedContentType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="expression-component" substitutionGroup="abstract-mixed-content-message-processor">
        <xsd:complexType>
            <xsd:complexContent mixed="true">
                <xsd:extension base="abstractMixedContentMessageProcessorType">
                    <xsd:attribute name="file" use="optional"/>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="abstract-shared-connector" abstract="true" type="abstractConnectorType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for connector elements. Connector elements allow properties to be configured across all endpoints that use the same transport. If multiple connectors are defined for the same transport, each endpoint must name which connector is being used.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="abstract-connector" abstract="true" type="abstractConnectorType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for connector elements. Connector elements allow properties to be configured across all endpoints that use the same transport. If multiple connectors are defined for the same transport, each endpoint must name which connector is being used.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractConnectorType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="name" type="substitutableName" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the connector so that other elements can reference it.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Agents -->
    <xsd:element name="abstract-agent" abstract="true" type="abstractAgentType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for agent elements. Are used to run processes as part of the server instance.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="abstractAgentType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-agent" type="customAgentType" substitutionGroup="abstract-agent"/>
    <xsd:complexType name="customAgentType">
        <xsd:complexContent>
            <xsd:extension base="abstractAgentType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
                <xsd:attribute name="name" type="substitutableName" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the agent in the registry.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-queue-store" abstract="true" type="abstractQueueStoreType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for queue store elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractQueueStoreType" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="defaultQueueStoreType">
        <xsd:complexContent>
            <xsd:extension base="abstractQueueStoreType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="queue-store" type="refQueueStoreType" substitutionGroup="abstract-queue-store">
        <xsd:annotation>
            <xsd:documentation>
                A reference to a queue store defined elsewhere.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="refQueueStoreType">
        <xsd:complexContent>
            <xsd:extension base="abstractQueueStoreType">
                <xsd:attribute name="ref" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the queue store to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-queue-store" type="customQueueStoreType" substitutionGroup="abstract-queue-store"/>
    <xsd:complexType name="customQueueStoreType">
        <xsd:complexContent>
            <xsd:extension base="abstractQueueStoreType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
                <xsd:attribute name="name" type="substitutableName" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the store in the registry.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="default-in-memory-queue-store" type="defaultQueueStoreType" substitutionGroup="abstract-queue-store">
        <xsd:annotation>
            <xsd:documentation>
                The default in-memory queue store for the application.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="default-persistent-queue-store" type="defaultQueueStoreType" substitutionGroup="abstract-queue-store">
        <xsd:annotation>
            <xsd:documentation>
                The default persistent queue store for the application.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="simple-in-memory-queue-store" type="defaultQueueStoreType" substitutionGroup="abstract-queue-store">
        <xsd:annotation>
            <xsd:documentation>
                DEPRECATED: simple-in-memory-queue-store is deprecated since Mule 3.5 and will be removed in Mule 4.0. Use default-in-memory-queue-store instead.
                A simple in-memeory queue store.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="file-queue-store" type="defaultQueueStoreType" substitutionGroup="abstract-queue-store">
        <xsd:annotation>
            <xsd:documentation>
                DEPRECATED: file-queue-store is deprecated since Mule 3.5 and will be removed in Mule 4.0. Use default-persistent-queue-store instead.
                A simple file-based queue store.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="abstract-global-endpoint" abstract="true" type="abstractGlobalEndpointType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for global endpoint elements. Global endpoints are named templates that allow you to define an endpoint once and refer to it in several places. The same template can be used for both inbound and outbound endpoints.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractGlobalEndpointType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="name" type="substitutableName" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the endpoint so that other elements can reference it. This name can also be referenced in the MuleClient.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-inbound-endpoint" abstract="true" type="abstractInboundEndpointType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for inbound endpoint elements. Inbound endpoints receive messages from the underlying transport. The message payload is then delivered to the component for processing.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractInboundEndpointType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="name" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the endpoint in the registry. There is no need to set the 'name' attribute on inbound or outbound endpoints, only on global endpoints.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-outbound-endpoint" abstract="true" type="abstractOutboundEndpointType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for outbound endpoint elements. Outbound endpoints dispatch messages to the underlying transport.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractOutboundEndpointType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="name" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the endpoint in the registry. There is not need to set the 'name' attribute on inbound or outbound endpoints, only on global endpoints.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Message Processors -->
    <xsd:element name="abstract-message-processor" abstract="true" type="abstractMessageProcessorType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for message processor elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-mixed-content-message-processor" abstract="true" type="abstractMixedContentMessageProcessorType" >
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for message processor elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractMixedContentMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="annotatedMixedContentType"/>
        </xsd:complexContent>
    </xsd:complexType>



    <xsd:element name="abstract-observer-message-processor" abstract="true" type="abstractObserverMessageProcessorType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for message processors that observe the message but do not mutate it used for exmaple for logging.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractObserverMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:group name="messageProcessorOrOutboundEndpoint">
        <xsd:choice>
            <xsd:element ref="abstract-message-processor">
                <xsd:annotation>
                    <xsd:documentation>
                        A message processor
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="abstract-outbound-endpoint">
                <xsd:annotation>
                    <xsd:documentation>
                        An outbound endpoint
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="abstract-mixed-content-message-processor"/>
        </xsd:choice>
    </xsd:group>

    <xsd:element name="processor" type="refMessageProcessorType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A reference to a message processor defined elsewhere.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="refMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
                <xsd:attribute name="ref" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the message processor to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-processor" type="customMessageProcessorType" substitutionGroup="abstract-message-processor"/>
    <xsd:complexType name="customMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
                <xsd:attribute name="name" type="substitutableName" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the message processor in the registry.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-empty-processor" type="abstractEmptyMessageProcessorType" substitutionGroup="abstract-message-processor"/>
    <xsd:complexType name="abstractEmptyMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="processor-chain" type="messageProcessorChainType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>The use of globally defined processor-chain element is deprecated since Mule 3.2.  Use sub-flow instead.</xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="sub-flow" type="subFlowType">
        <xsd:annotation>
            <xsd:documentation>
                A chain of message processors processed synchronously that can be referenced and reused.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="subFlowType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:sequence>
                    <xsd:element name="description" type="descriptionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                This can hold any kind of documentation related to the sub-flow. It is intended to be
                                "human readable" only and  is not used by the system.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" maxOccurs="unbounded" />
                </xsd:sequence>
                <xsd:attribute name="name" type="nonBlankString" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the sub-flow in the registry.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="messageProcessorChainType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
                <xsd:sequence>
                    <xsd:element name="description" type="descriptionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                This can hold any kind of documentation related to the processor chain. It is intended to be "human readable" only and
                                is not used by the system.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="name" type="substitutableName" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the message processor in the registry.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="invoke" type="invokeType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Invokes the method of a given object using method arguments expressed using mule expressions.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="invokeType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
                <xsd:attribute name="object-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Reference to the object whose method will be invoked.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="method" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the method to be invoked.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="methodArguments" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Comma-seperated list of mule expression that when evaluated are the arguments for the method invocation
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="methodArgumentTypes" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Comma-seperated list of mule expression that when evaluated are the arguments for the method invocation
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="name" type="substitutableName" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the message processor in the registry.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:element name="enricher" type="messageEnricherType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Enriches the current message, using expressins to define source and target,
                with the result of processing a nested message processor.  Use the target and optionally sourcre attributes
                for 1-1 enrichment.  If you require n-m enrichment than use the child 'enrich' elements instead.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="messageEnricherType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" />
                    <xsd:element name="enrich" type="extractEnrichPairType" minOccurs="0"
                        maxOccurs="unbounded" />
                </xsd:sequence>
                <xsd:attribute name="source" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            An evaluator expression used to extract a value from the result of the
                            enrichment message processor. If an
                            expression is not specified then the payload of the
                            message is used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="target" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The enricher expression used to enrich the current message with the result
                            the processing of the enrichement message processor specified.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="extractEnrichPairType">
        <xsd:attributeGroup ref="enricherSourceTargetAttributes" />
    </xsd:complexType>

    <xsd:attributeGroup name="enricherSourceTargetAttributes">
        <xsd:attribute name="source" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    An evaluator expression used to extract a value from the result of the
                    enrichment message processor. If an
                    expression is not specified then the payload of the
                    message is used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="target" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    The enricher expression used to enrich the current message with the result
                    the processing of the enrichement message processor specified.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:element name="async" type="asyncType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Processes the nested list of message processors asynchronously using a thread pool
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="asyncType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" maxOccurs="unbounded"/>
                </xsd:sequence>
                 <xsd:attribute name="processingStrategy" use="optional" default="queued-asynchronous">
                    <xsd:annotation>
                        <xsd:documentation>
                            Strategy used to process the configured message processors when exchange pattern is 'one-way'.  
                            This attribute accepts either one of the enumerated strategies with default configuration options or a reference to a gloablly defined strategy.
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:union>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:string">
                                    <xsd:annotation>
                                        <xsd:documentation>
                                            The name of a globally configured processing strategy
                                        </xsd:documentation>
                                    </xsd:annotation>
                                </xsd:restriction>
                            </xsd:simpleType>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:NMTOKEN">
                                    <xsd:enumeration value="asynchronous">
                                        <xsd:annotation>
                                            <xsd:documentation>
                                                Uses a thread pool to process the pipeline of message processors asynchronously.
                                            </xsd:documentation>
                                        </xsd:annotation>
                                    </xsd:enumeration>
                                    <xsd:enumeration value="queued-asynchronous">
                                        <xsd:annotation>
                                            <xsd:documentation>
                                                Decouples the recieving of a new message from it's processing using a queue. 
                                                The queue is polled and a thread pool is used to process the pipeline of message processors asynchronously.
                                            </xsd:documentation>
                                        </xsd:annotation>
                                    </xsd:enumeration>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:union>
                    </xsd:simpleType>
                </xsd:attribute>
                <xsd:attribute name="name" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Optional name that will be used to name the threads used by this flow.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="request-reply" type="requestReplyType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Provides support for the asynchronous request/reply pattern where a message is sent via a one-way outbound endpoint
                and an asynchronous response is received via a seperate inbound one-way endpoint.  Message flow is blocked while
                waiting for the reply message.  Note: This does not currently support setting of replyTo property on the outbound message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="requestReplyType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint">
                        <xsd:annotation>
                            <xsd:documentation>
                                The outbound endpoint or message processor that will perform the asynchronous request.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:group>
                    <xsd:element ref="abstract-inbound-endpoint">
                        <xsd:annotation>
                            <xsd:documentation>
                                The inbound endpoint from which the asynchronous reply message will be received.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="timeout" type="substitutableInt" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The time (ms) to wait for an asynchronous reply message to be received.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="storePrefix" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines the prefix of the object store names.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-poll-override" abstract="true" type="abstractPollOverrideType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for poll overrides
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractPollOverrideType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:element name="watermark" type="watermarkType" substitutionGroup="abstract-poll-override">
        <xsd:annotation>
            <xsd:documentation>
                Defines watermark based synchronization parameters
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="watermarkType">
        <xsd:complexContent>
            <xsd:extension base="abstractPollOverrideType">
                <xsd:attribute name="variable" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The key that is going to be used to store/retrieve the watermark
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="default-expression" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The default value to be used for the watermark
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="update-expression" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The expression to be used to update the watermark
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="selector" use="optional">
                	<xsd:simpleType>
						<xsd:restriction base="substitutableName">
							<xsd:enumeration value="MIN"/>
							<xsd:enumeration value="MAX"/>
							<xsd:enumeration value="FIRST"/>
							<xsd:enumeration value="LAST"/>
						</xsd:restriction>
					</xsd:simpleType>
                </xsd:attribute>
                <xsd:attribute name="selector-expression" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The expression to retrieve the values the selector will evaluate
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="object-store-ref" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The object store where the watermark is going to be stored
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:element name="logger" type="loggerType" substitutionGroup="abstract-observer-message-processor">
        <xsd:annotation>
    <xsd:documentation>
        Performs logging using an expression that determines what should be logged. By default the current messages is
        logged using the DEBUG level to the 'org.mule.api.processor.LoggerMessageProcessor' category but the level and
        category can both be configured to suit your needs.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="loggerType">
        <xsd:complexContent>
            <xsd:extension base="abstractObserverMessageProcessorType">
                <xsd:attribute name="message" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Message that will be logged.  Embedded expressions can be used to extract value from the current message.  If no message is
                            specified then the current message is used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="level" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The logging level to be used. Default is DEBUG.
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:string">
                            <xsd:enumeration value="ERROR"/>
                            <xsd:enumeration value="WARN"/>
                            <xsd:enumeration value="INFO"/>
                            <xsd:enumeration value="DEBUG"/>
                            <xsd:enumeration value="TRACE"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
                <xsd:attribute name="category" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The log category to be used
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--  TODO
    <xsd:element name="seda-stage" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Processes the nest list of message processors asychronously using a seda stage.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="asyncType">
                    <xsd:sequence>
                        <xsd:element ref="queue-profile" minOccurs="0"/>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    -->

    <xsd:element name="transactional" type="abstractTransactional" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Processes the nest list of message processors within a transaction
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="abstractTransactional">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" maxOccurs="unbounded"/>
                    <xsd:element ref="abstract-exception-strategy" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="action" type="transactionalActionType" default="ALWAYS_BEGIN"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="transactionalActionType">
        <xsd:restriction base="xsd:NMTOKEN">
            <xsd:enumeration value="ALWAYS_BEGIN"/>
            <xsd:enumeration value="BEGIN_OR_JOIN"/>
        </xsd:restriction>
    </xsd:simpleType>


    <!-- Message Sources -->
    <xsd:element name="abstract-message-source" abstract="true" type="abstractMessageSourceType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for message source elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractMessageSourceType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:group name="messageSourceOrInboundEndpoint">
        <xsd:choice>
            <xsd:element ref="abstract-message-source">
                <xsd:annotation>
                    <xsd:documentation>
                        A message source
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="abstract-inbound-endpoint">
                <xsd:annotation>
                    <xsd:documentation>
                        An inbound endpoint
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:choice>
    </xsd:group>

    <xsd:element name="custom-source" type="customMessageSourceType" substitutionGroup="abstract-message-source"/>
    <xsd:complexType name="customMessageSourceType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageSourceType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="composite-source" type="compositeMessageSourceType" substitutionGroup="abstract-message-source"/>
    <xsd:complexType name="compositeMessageSourceType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageSourceType">
                <xsd:sequence maxOccurs="unbounded">
                    <xsd:group ref="messageSourceOrInboundEndpoint"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="commonTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-transformer" abstract="true" type="commonTransformerType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for transformer elements. Transformers convert message payloads.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractTransformerType">
        <xsd:complexContent>
            <xsd:extension base="commonTransformerType">
                <xsd:attribute name="name" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the transformer so that other elements can reference it. Required if the transformer is defined at the global level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="returnClass" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The class of the message generated by the transformer. This is used if transformers are auto-selected and to validate that the transformer returns the correct type.  Note that if you need to specify an array type you need postfix the class name with '[]'. For example, if you want return a an Orange[], you set the return class to 'org.mule.tck.testmodels.fruit.Orange[]'.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="ignoreBadInput" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            Many transformers only accept certain classes. Such transformers are never called with inappropriate input (whatever the value of this attribute). If a transformer forms part of a chain and cannot accept the current message class, this flag controls whether the remaining part of the chain is evaluated. If true, the next transformer is called. If false the chain ends, keeping the result generated up to that point.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attributeGroup ref="mimeTypeAttributes">
                    <xsd:annotation>
                        <xsd:documentation>
                            The mime type of the transformer's output
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attributeGroup>
                <xsd:attribute name="encoding" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            String encoding used for transformer output.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="globalPropertyType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="name" type="substitutableName" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the property. This is used inside Spring placeholders.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="value" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The value of the property. This replaces each occurence of a Spring placeholder.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- seemed pointless making these simple container types abstract -->
    <xsd:complexType name="inboundCollectionType">
        <xsd:sequence>
            <xsd:element ref="abstract-inbound-endpoint" minOccurs="0" maxOccurs="unbounded"/>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element ref="abstract-inbound-router"/>
                <xsd:element ref="abstract-transformer" />
                <xsd:element ref="splitter"/>
                <xsd:element ref="collection-splitter"/>
                <xsd:element ref="processor"/>
                <xsd:element ref="custom-processor"/>
            </xsd:choice>
            <xsd:element ref="abstract-catch-all-strategy" minOccurs="0"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:element name="abstract-catch-all-strategy" abstract="true" type="abstractCatchAllStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for catch-all strategy elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractCatchAllStrategyType"/>

    <xsd:element name="abstract-inbound-router" abstract="true" type="abstractInboundRouterType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for inbound router elements, which control how incoming messages are handled.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractInboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-filter" abstract="true" type="commonFilterType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for filter elements, which control which messages are handled.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="commonFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="abstractFilterType">
        <xsd:complexContent>
            <xsd:extension base="commonFilterType">
                <xsd:attribute name="name" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the filter so that other elements can reference it. Required if the filter is defined at the global level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="outboundCollectionType">
        <xsd:sequence>
            <xsd:element ref="abstract-outbound-router" maxOccurs="unbounded"/>
            <xsd:element ref="abstract-catch-all-strategy" minOccurs="0"/>
        </xsd:sequence>
        <xsd:attribute name="matchAll" type="substitutableBoolean" default="false">
            <xsd:annotation>
                <xsd:documentation>
                    If true, the output message will be sent to all routers. Otherwise, only the first matching router is used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-outbound-router" abstract="true" type="abstractOutboundRouterType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for outbound router elements, which control how outgoing messages are delivered to the outbound endpoints.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-transaction-manager" abstract="true" type="abstractTransactionManagerType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for transaction manager elements, which are used to coordinate transactions.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="abstract-shared-transaction-manager" abstract="true" type="abstractTransactionManagerType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for transaction manager elements that can be defined as shared resource, which are used to coordinate transactions.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractTransactionManagerType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="configurationType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:sequence>
                    <xsd:element name="default-threading-profile" type="threadingProfileType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The default threading profile, used by components and by endpoints for dispatching and receiving if no more specific configuration is given.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="default-dispatcher-threading-profile" type="threadingProfileType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The default dispatching threading profile, which modifies the default-threading-profile values and is used by endpoints for dispatching messages. This can also be configured on connectors, in which case the connector configuration is used instead of this default.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="default-receiver-threading-profile" type="threadingProfileType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The default receiving threading profile, which modifies the default-threading-profile values and is used by endpoints for receiving messages. This can also be configured on connectors, in which case the connector configuration is used instead of this default.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="default-service-threading-profile" type="threadingProfileType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The default service threading profile, which modifies the default-threading-profile and is used by services for processing messages. This can also be configured on models or services, in which case these configurations will be used instead of this default.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="abstract-reconnection-strategy" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The default reconnection strategy, used by connectors and endpoints. This can also be configured on connectors, in which case the connector configuration is used instead of this default.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="expression-language" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Configuration of Mule Expression Language
                            </xsd:documentation>
                        </xsd:annotation>
                        <xsd:complexType>
                            <xsd:complexContent mixed="true">
                                <xsd:extension base="abstractMixedContentExtensionType">
                                    <xsd:sequence>
                                        <xsd:element minOccurs="0" maxOccurs="unbounded" name="import">
                                            <xsd:complexType>
                                                <xsd:attribute name="name" type="nonBlankString" />
                                                <xsd:attribute name="class" use="required" type="substitutableClass" />
                                            </xsd:complexType>
                                        </xsd:element>
                                        <xsd:element minOccurs="0" maxOccurs="unbounded" name="alias">
                                            <xsd:complexType>
                                                <xsd:attribute name="name" use="required" type="nonBlankString" />
                                                <xsd:attribute name="expression" use="required" type="nonBlankString" />
                                            </xsd:complexType>
                                        </xsd:element>
                                        <xsd:element minOccurs="0" maxOccurs="1" name="global-functions" >
                                            <xsd:complexType mixed="true">
                                                <xsd:attribute name="file" type="nonBlankString" />
                                            </xsd:complexType>
                                        </xsd:element>
                                    </xsd:sequence>
                                    <xsd:attribute name="autoResolveVariables" default="true" type="substitutableBoolean" />
                                </xsd:extension>
                            </xsd:complexContent>
                        </xsd:complexType>
                    </xsd:element>
                    <xsd:element ref="abstract-configuration-extension" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Mule application configuration extensions. Extensions can be defined as child of the configuration elements and then accessed by each module that defines it.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="defaultResponseTimeout" type="xsd:string" default="10000">
                    <xsd:annotation>
                        <xsd:documentation>
                            The default period (ms) to wait for a synchronous response.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="defaultTransactionTimeout" type="xsd:string" default="30000">
                    <xsd:annotation>
                        <xsd:documentation>
                            The default timeout (ms) for transactions. This can also be configured on transactions, in which case the transaction configuration is used instead of this default.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="defaultExceptionStrategy-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The default exception strategy for every flow / service. This must be a reference to a global exception strategy.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="shutdownTimeout" type="substitutableInt" default="5000">
                    <xsd:annotation>
                        <xsd:documentation>
                            (As of Mule 2.2.2) The time in milliseconds to wait for any in-progress messages to finish processing before Mule shuts down. After this threshold has been reached, Mule starts interrupting threads, and messages can be lost. If you have a very large number of services in the same Mule instance, if you have components that take more than a couple seconds to process, or if you are using large payloads and/or slower transports, you should increase this value to allow more time for graceful shutdown. The value you specify is applied to services and separately to dispatchers, so the default value of 5000 milliseconds specifies that Mule has ten seconds to process and dispatch messages gracefully after shutdown is initiated.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maxQueueTransactionFilesSize" type="substitutableInt" default="500">
                    <xsd:annotation>
                        <xsd:documentation>
                            The approximated maximum space in megabytes used by the transaction log files for transactional persistent queues. Take into account that this number applies both to the set of transaction log files for XA and for local transactions. If both type of transactions are used then the approximated maximum space used will be twice the configured value.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="useExtendedTransformations" type="substitutableBoolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            Backwards Compatabilty Flag: Used to disable the new extended transformation support introduced in Mule 3.3 including enforcement of transformations, implicit transformations and no direct transformer lookup.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="flowEndingWithOneWayEndpointReturnsNull" type="substitutableBoolean" default="false">
                    <xsd:annotation>
                        <xsd:documentation>
                            Backwards Compatabilty Flag: Used to revert to Mule 3.2 behaviour of one-way outbound endpoints when they are the last element inside a request-response flow. When true the value returned by the endpoint will be null, otherwise will be an echo of the received event.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="enricherPropagatesSessionVariableChanges" type="substitutableBoolean" default="false">
                    <xsd:annotation>
                        <xsd:documentation>
                            Backwards Compatabilty Flag:  Used to revert to Mule 3.1/3.2 behaviour of the message enricher so that session variables added or modified within an enricher are propagated up into the flow where the enricher is used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="defaultObjectSerializer-ref" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            An optional reference to an ObjectSerializer to be used as the application's default
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="defaultProcessingStrategy" type="flowProcessingStrategyType" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The default processing strategy to use in all flows which don't specify otherwise
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-configuration-extension" abstract="true" type="abstractConfigurationExtensionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for arbitrary extensions as children of the 'configuration' element. Other transports and modules can extend this if they need to add elements to the configuration.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractConfigurationExtensionType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="notificationManagerType">
        <xsd:complexContent >
            <xsd:extension base="annotatedType">
                <xsd:sequence>
                    <xsd:element name="notification" type="defineNotificationType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Associates an event with an interface. Listeners that implement the interface will receive instances of the event.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="disable-notification" type="disableNotificationType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Blocks the association of an event with a particular interface. This filters events after the association with a particular interface (and so takes precedence).
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="notification-listener" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Registers a bean as a listener with the notification system. Events are dispatched by reflection - the listener will receive all events associated with any interfaces it implements. The relationship between interfaces and events is configured by the notification and disable-notification elements.
                            </xsd:documentation>
                        </xsd:annotation>
                        <xsd:complexType>
                            <xsd:attribute name="ref" type="xsd:string" use="required">
                                <xsd:annotation>
                                    <xsd:documentation>
                                        The bean that will receive notifications.
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:attribute>
                            <xsd:attribute name="subscription" type="xsd:string">
                                <xsd:annotation>
                                    <xsd:documentation>
                                        An optional string that is compared with the event resource identifier. Only events with matching identifiers will be sent. If no value is given, all events are sent.
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:attribute>
                        </xsd:complexType>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="dynamic" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            If the notification manager is dynamic, listeners can be registered dynamically at runtime via the MuleContext, and the configured notification can be changed. Otherwise, some parts of Mule will cache notification configuration for efficiency and will not generate events for newly enabled notifications or listeners. The default value is false.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="defineNotificationType">
        <xsd:attribute name="event-class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The class associated with a notification event that will be delivered to the interface. This can be used instead of the 'event' attribute to specify a custom class.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="event" type="notificationTypes">
            <xsd:annotation>
                <xsd:documentation>
                    The notification event to deliver.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="interface-class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The interface (class name) that will receive the notification event.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="interface" type="notificationTypes">
            <xsd:annotation>
                <xsd:documentation>
                    The interface that will receive the notification event.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="disableNotificationType">
        <xsd:attribute name="event-class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The class associated with an event that will no longer be delivered to any interface. This can be used instead of the 'event' attribute to specify a custom class.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="event" type="notificationTypes">
            <xsd:annotation>
                <xsd:documentation>
                    The event you no longer want to deliver.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="interface-class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The interface (class name) that will no longer receive the event.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="interface" type="notificationTypes">
            <xsd:annotation>
                <xsd:documentation>
                    The interface that will no longer receive the event.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>


    <xsd:simpleType name="notificationTypes">
        <xsd:restriction base="xsd:NMTOKEN">
            <xsd:enumeration value="CONTEXT"/>
            <xsd:enumeration value="MODEL">
                <xsd:annotation>
                    <xsd:documentation>
                        DEPRECATED: The use of 'model' and 'service' is deprecated in Mule 3.4 and will be removed in Mule 4.0. As such this
                        notification is also deprecated and will be removed in Mule 4.0.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="SERVICE">
                <xsd:annotation>
                    <xsd:documentation>
                        DEPRECATED: The use of 'model' and 'service' is deprecated in Mule 3.4 and will be removed in Mule 4.0. As such this
                        notification is also deprecated and will be removed in Mule 4.0.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:enumeration>
            <xsd:enumeration value="SECURITY"/>
            <xsd:enumeration value="ASYNC-MESSAGE"/>
            <xsd:enumeration value="ENDPOINT-MESSAGE"/>
            <xsd:enumeration value="CONNECTOR-MESSAGE"/>
            <xsd:enumeration value="COMPONENT-MESSAGE"/>
            <xsd:enumeration value="PIPELINE-MESSAGE"/>
            <xsd:enumeration value="MANAGEMENT"/>
            <xsd:enumeration value="MESSAGE-PROCESSOR"/>
            <xsd:enumeration value="EXCEPTION-STRATEGY"/>
            <xsd:enumeration value="CONNECTION"/>
            <xsd:enumeration value="REGISTRY"/>
            <xsd:enumeration value="CUSTOM"/>
            <xsd:enumeration value="EXCEPTION"/>
            <xsd:enumeration value="TRANSACTION"/>
            <xsd:enumeration value="ROUTING"/>
        </xsd:restriction>
    </xsd:simpleType>
    <!--==============================================================-->
    <!-- Models                                                       -->
    <!--==============================================================-->

    <xsd:element name="abstract-model" abstract="true" type="abstractModelType">
        <xsd:annotation>
            <xsd:documentation>
                DEPRECATED: The 'model' element is deprecated in Mule 3.4 and will be removed in Mule 4.0.  Flows do not need to be configured inside a 'model' element. 
                A placeholder for model elements. A model provides basic settings and processing for all the services it contains.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractModelType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:sequence>
                    <xsd:element ref="legacy-abstract-exception-strategy" minOccurs="0"/>
                    <xsd:group ref="entryPointResolvers"/>
                    <xsd:element ref="abstract-service" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="name" type="nonBlankString">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name used to identify this model.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="seda-model" type="sedaModelType" substitutionGroup="abstract-model">
        <xsd:annotation>
            <xsd:documentation>
                DEPRECATED: The 'model' element is deprecated in Mule 3.4 and will be removed in Mule 4.0.  Flows do not need to be configured inside a 'model' element. 
                A staged event-driven architecture (SEDA) model has separate threads and queues for each service.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="sedaModelType">
        <xsd:complexContent>
            <xsd:extension base="abstractModelType">
                <xsd:sequence>
                    <xsd:element ref="abstract-queue-profile" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="inherit" type="xsd:boolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            If true, this model element is an extension of a previous model element with the same name.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="model" type="defaultModelType" substitutionGroup="abstract-model">
        <xsd:annotation>
            <xsd:documentation>
                DEPRECATED: The 'model' element is deprecated in Mule 3.4 and will be removed in Mule 4.0.  Flows do not need to be configured inside a 'model' element. 
                The container for a set of services, providing basic settings and processing for all the services it contains.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="defaultModelType">
        <xsd:complexContent>
            <xsd:extension base="sedaModelType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Model elements -->

    <xsd:element name="abstract-queue-profile" abstract="true" type="abstractQueueProfileType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for a queue profile, which controls how messages are queued.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractQueueProfileType"/>

    <!-- to give a cleaner config we allow either a set or an individual entry (but not both).-->
    <xsd:group name="entryPointResolvers">
        <xsd:choice>
            <xsd:element ref="abstract-entry-point-resolver-set" minOccurs="0"/>
            <!-- we could allow many of these, but it looks ugly -->
            <xsd:element ref="abstract-entry-point-resolver" minOccurs="0"/>
        </xsd:choice>
    </xsd:group>

    <xsd:element name="abstract-entry-point-resolver-set" abstract="true" type="abstractEntryPointResolverSetType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for entry point resolver set elements. These combine a group of entry point resolvers, trying them in turn until one succeeds.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractEntryPointResolverSetType"/>

    <xsd:element name="legacy-entry-point-resolver-set" type="extensibleEntryPointResolverSet"
                 substitutionGroup="abstract-entry-point-resolver-set">
        <xsd:annotation>
            <xsd:documentation>
                An extensible set of entry point resolvers (which determine how a message is passed to a component in Java) that already contains resolvers to implement the standard logic. This is already provided by default and is only needed explicitly if it will be extended with other entry point resolvers. This element can be set on the model or component; the model value provides a default that individual component values can override.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="entry-point-resolver-set" type="extensibleEntryPointResolverSet"
                 substitutionGroup="abstract-entry-point-resolver-set">
        <xsd:annotation>
            <xsd:documentation>
                An extensible set of entry point resolvers. These determine how a message is passed to a component in Java. Each entry point resolver is tried in turn until one succeeds in delivering the message to the component. This element can be set on the model or component; the model value provides a default that individual component values can override.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="extensibleEntryPointResolverSet">
        <xsd:complexContent>
            <xsd:extension base="abstractEntryPointResolverSetType">
                <xsd:sequence>
                    <xsd:element ref="abstract-entry-point-resolver" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-entry-point-resolver-set" type="customEntryPointResolverSetType"
                 substitutionGroup="abstract-entry-point-resolver-set">
        <xsd:annotation>
            <xsd:documentation>
                A custom entry point resolver set. This allows user-supplied code to determine how a message is passed to a component in Java. This element can be set on the model or component; the model value provides a default that individual component values can override.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customEntryPointResolverSetType">
        <xsd:complexContent>
            <xsd:extension base="abstractEntryPointResolverSetType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the EntryPointResolverSet interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-entry-point-resolver" abstract="true" type="abstractEntryPointResolverType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for an entry point resolver element. Entry point resolvers define how payloads are delivered to Java code by choosing the method to call.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="callable-entry-point-resolver" type="abstractEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                An entry point resolver for components that implement the Callable interface. This passes a MuleEventContext to the component. This element can be set on the model or component; the model value provides a default that individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractEntryPointResolverType"/>

    <xsd:element name="custom-entry-point-resolver" type="customEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                A custom entry point resolver. This allows user-supplied code to determine how a message is passed to a component in Java. This element can be set on the model or component; the model value provides a default that individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="abstractEntryPointResolverType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the EntryPointResolver interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="baseEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="abstractEntryPointResolverType">
                <xsd:attribute name="acceptVoidMethods" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            Whether the resolver should call void methods. By default, void methods are not considered as possible candidates for message delivery.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="property-entry-point-resolver" type="propertyEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Uses a message property to select the component method to be called. This element can be set on the model or component; the model value provides a default that individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="propertyEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="baseEntryPointResolverType">
                <xsd:attribute name="property" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the message property used to select a method on the component.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="method-entry-point-resolver" type="methodEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Delivers the message to a named method. This element can be set on the model or component; the model value provides a default that individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="methodEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="baseEntryPointResolverType">
                <xsd:sequence>
                    <xsd:element ref="include-entry-point" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="reflection-entry-point-resolver" type="reflectionEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Generates a list of candidate methods from the component via reflections. This element can be set on the model or component; the model value provides a default that individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="reflectionEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="baseEntryPointResolverType">
                <xsd:sequence>
                    <xsd:element name="exclude-object-methods" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                If specified, methods in the Java Object interface are not included in the list of possible methods that can receive the message.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="exclude-entry-point" type="methodType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Explicitly excludes a named method from receiving the message.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="array-entry-point-resolver" type="complexEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Delivers the message to a method that takes a single array as argument. This element can be set on the model or component; the model value provides a default that individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="no-arguments-entry-point-resolver" type="complexEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Calls a method without arguments (the message is not passed to the component).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="complexEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="reflectionEntryPointResolverType">
                <xsd:sequence>
                    <xsd:element ref="include-entry-point" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="enableDiscovery" type="substitutableBoolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            If no method names are configured, attempts to discover the method to invoke based on the inbound message type.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="include-entry-point" type="methodType">
        <xsd:annotation>
            <xsd:documentation>
                A possible method for delivery.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="methodType">
        <xsd:attribute name="method" type="nonBlankString">
            <xsd:annotation>
                <xsd:documentation>
                    The name of the method.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!--==============================================================-->
    <!--  Services                                                    -->
    <!--==============================================================-->

    <xsd:element name="abstract-service" abstract="true" type="abstractServiceType">
        <xsd:annotation>
            <xsd:documentation>
                DEPRECATED: Services are deprecated in Mule 3.4 and will be removed in Mule 4.0. 
                A placeholder for a service element. Services combine message routing with a component (typically a POJO).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractServiceType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="name" type="nonBlankString" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name used to identify this service.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="baseServiceType">
        <xsd:annotation>
            <xsd:documentation>
                Base support for a model-based wrapper around the POJO service (SEDA, Streaming, etc.)
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractServiceType">
                <xsd:sequence>
                    <xsd:element name="description" type="descriptionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                This can hold any kind of documentation related to the service. It is intended to be "human readable" only and is not used by the system.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="inbound" type="inboundCollectionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The elements within 'inbound' describe how a service receives messages.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <!-- minOccurs="0" to allow for <forwarding-router/> and/or default component -->
                    <xsd:element ref="abstract-component" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The service component that is invoked when incoming messages are received. If this element is not present, the service simply bridges the inbound and outbound using a pass-through component.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="outbound" type="outboundCollectionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The elements within 'outbound' describe how a service sends or dispatches messages.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="async-reply" type="asyncReplyCollectionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The elements within 'async-reply' describe how asynchronous replies are handled.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="legacy-abstract-exception-strategy" minOccurs="0"/>
                    <xsd:element ref="abstract-message-info-mapping" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The message info mapper used to extract key bits of the message
                                information, such as Message ID or Correlation ID. these
                                properties
                                are used by some routers and this mapping information tells Mule
                                where to get the information from in the current message.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="initialState" default="started">
                    <xsd:annotation>
                        <xsd:documentation>
                            The initial state of the service. Usually a service is started automatically ("started"), but this attribute can be used to disable initial startup ("stopped") or start the service in a paused state ("paused").
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="started"/>
                            <xsd:enumeration value="stopped"/>
                            <xsd:enumeration value="paused"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- This is left in for backwards-compatibility only, remove for next major version. -->
    <xsd:element name="legacy-abstract-exception-strategy" abstract="true" type="exceptionStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                Legacy placeholder for an exception strategy element. Exception strategies define how Mule should react to errors.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="abstract-exception-strategy" abstract="true" type="exceptionStrategyType" substitutionGroup="legacy-abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for an exception strategy element. Exception strategies define how Mule should react to errors.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="exceptionStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                Base type for every exception strategy.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="referenceExceptionStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                Used to reference another exception strategy within flow, service or global exception strategy.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="exceptionStrategyType">
                <xsd:attribute name="ref" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the filter to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="abstractNotificationExceptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="exceptionStrategyType">
                <xsd:attribute name="enableNotifications" type="xsd:boolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            Determines whether ExceptionNotifications will be fired from this strategy when an exception occurs. Default is true.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="name" type="substitutableName" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Name of the exception strategy that will be used in ref attribute of 'exception-strategy' element
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="when" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The expression that will be evaluated to determine if this exception strategy should be executed. This should always be a boolean expression.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="logException" use="optional" type="expressionBoolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            Determines whether the handled exception will be logged to its standard logger in the ERROR level before being handled. Default is true.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="abstractExceptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractNotificationExceptionStrategyType">
                <xsd:sequence>
                    <xsd:element name="commit-transaction" type="exceptionPatternType" maxOccurs="1" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                            These exceptions will be considered "delivered" after handling by the exception strategy.  Any exception not
                            accepted by this filter will be redelivered/rolled back.
                            You can set a comma-separated list of wildcard patterns that will be matched against the fully qualified class name of the current exception.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="rollback-transaction" type="exceptionPatternType" maxOccurs="1" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                            These exceptions will be redelivered/rolled back after handling by the exception strategy.
                            You can set a comma-separated list of wildcard patterns that will be matched against the fully qualified class name of the current exception.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>Destination to which an ExceptionMessage will be sent; this could be an outbound endpoint, a router, or other message processor.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:group>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="exceptionPatternType">
        <xsd:attribute name="exception-pattern" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation>A comma-separated list of wildcard expressions that will be matched against the fully qualified classname of the current exception received by the ExceptionStrategy.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!--==============================================================-->
    <!--   Reconnection strategies                                    -->
    <!--==============================================================-->

    <xsd:element name="abstract-reconnection-strategy" abstract="true" type="abstractReconnectionStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for a reconnection strategy element. Reconnection strategies define how Mule should attempt to handle a connection failure.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractReconnectionStrategyType">
        <xsd:sequence>
            <xsd:element ref="abstract-reconnect-notifier" minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
        <xsd:attribute name="blocking" type="substitutableBoolean" default="true">
            <xsd:annotation>
                <xsd:documentation>If false, the reconnection strategy will run in a separate, non-blocking thread</xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-reconnect-notifier" abstract="true" type="abstractReconnectNotifierType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for a reconnection notifier element. The RetryNotifier interface is a callback that allows actions to be performed after each reconnection attempt, e.g., firing server notification events on success or failure.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractReconnectNotifierType"/>

    <xsd:element name="reconnect" type="reconnectSimpleStrategyType"
                 substitutionGroup="abstract-reconnection-strategy">
        <xsd:annotation>
            <xsd:documentation>
                A reconnection strategy that allows the user to configure how many times a reconnection should be attempted and how long to wait between attempts.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="reconnectSimpleStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractReconnectionStrategyType">
                <xsd:attribute name="frequency" type="substitutableLong" default="2000">
                    <xsd:annotation>
                        <xsd:documentation>How often (in ms) to reconnect</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="count" type="substitutableInt" default="2">
                    <xsd:annotation>
                        <xsd:documentation>How many reconnection attempts to make</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="reconnect-forever" type="reconnectForeverStrategyType"
                 substitutionGroup="abstract-reconnection-strategy">
        <xsd:annotation>
            <xsd:documentation>
                A reconnection strategy that retries an infinite number of times at the specified frequency.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="reconnectForeverStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractReconnectionStrategyType">
                <xsd:attribute name="frequency" type="substitutableLong" default="2000">
                    <xsd:annotation>
                        <xsd:documentation>How often (in ms) to reconnect</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="reconnect-custom-strategy" type="reconnectCustomStrategyType"
                 substitutionGroup="abstract-reconnection-strategy">
        <xsd:annotation>
            <xsd:documentation>
                A user-defined reconnection strategy.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="reconnectCustomStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractReconnectionStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>A class that implements the RetryPolicyTemplate interface.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="reconnect-notifier" type="reconnectNotifierType"
                 substitutionGroup="abstract-reconnect-notifier">
        <xsd:annotation>
            <xsd:documentation>
                Fires a ConnectionNotification upon each reconnection attempt.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="reconnectNotifierType">
        <xsd:complexContent>
            <xsd:extension base="abstractReconnectNotifierType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="reconnect-custom-notifier" type="reconnectCustomNotifierType"
                 substitutionGroup="abstract-reconnect-notifier">
        <xsd:annotation>
            <xsd:documentation>
                A user-defined reconnection notifier.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="reconnectCustomNotifierType">
        <xsd:complexContent>
            <xsd:extension base="abstractReconnectNotifierType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>A class that implements the RetryNotifier interface.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    
    <xsd:complexType name="asyncReplyCollectionType">
        <xsd:sequence>
            <xsd:element ref="abstract-inbound-endpoint" minOccurs="1" maxOccurs="unbounded"/>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element ref="abstract-async-reply-router"/> <!-- Deprecated -->
                <xsd:element ref="abstract-inbound-router"/>
                <xsd:element ref="processor"/>
                <xsd:element ref="custom-processor"/>
            </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="timeout" type="substitutableInt">
            <xsd:annotation>
                <xsd:documentation>
                    The timeout (ms) to wait for a reply.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="failOnTimeout" type="substitutableBoolean">
            <xsd:annotation>
                <xsd:documentation>
                    If the router times out before all expected events have been received, specifies whether an exception should be thrown (true) or the current events should be returned for processing (false). The default is true.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-async-reply-router" abstract="true" type="abstractAsyncReplyRouterType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for an async reply router element. Asynchronous replies are handled via this router.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractAsyncReplyRouterType"/>

    <xsd:element name="service" type="sedaServiceType" substitutionGroup="abstract-service">
        <xsd:annotation>
            <xsd:documentation>
                DEPRECATED: Services are deprecated in Mule 3.4 and will be removed in Mule 4.0.
                Describes how to receive messages, deliver them to a component, and handle the results (if any).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="sedaServiceType">
        <xsd:complexContent>
            <xsd:extension base="baseServiceType">
                <xsd:sequence>
                    <xsd:element ref="abstract-service-threading-profile" minOccurs="0"/>
                    <xsd:element ref="abstract-queue-profile" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="queueTimeout" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The timeout used when taking messages from the service queue.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-service" type="customServiceType" substitutionGroup="abstract-service">
        <xsd:annotation>
            <xsd:documentation>
                DEPRECATED: Services are deprecated in Mule 3.4 and will be removed in Mule 4.0.
                A user-implemented service (typically used only in testing).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customServiceType">
        <xsd:complexContent>
            <xsd:extension base="baseServiceType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The class to use for the service.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-service-threading-profile" abstract="true"
                 type="abstractServiceThreadingProfileType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for the service threading profile element. Threading profiles define how thread pools are used by a service.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractServiceThreadingProfileType"/>

    <!--==============================================================-->
    <!--   Flow Constructs                                            -->
    <!--==============================================================-->

    <xsd:element name="abstract-flow-construct" abstract="true" type="abstractFlowConstructType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for a flow construct element.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractFlowConstructType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="name" type="nonBlankString" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name used to identify this flow construct.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="abstract" type="xsd:boolean" use="optional" default="false">
                    <xsd:annotation>
                        <xsd:documentation>
                            Determines if the flow construct is abstract (ie a parent that will be inherited in concrete constructs).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="parent" type="xsd:NMTOKEN" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Determines if the flow construct inherits part of its configuration from a parent construct.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="baseFlowConstructType">
        <xsd:annotation>
            <xsd:documentation>
                Base support for a flow construct.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractFlowConstructType">
                <xsd:sequence>
                    <xsd:element name="description" type="descriptionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                This can hold any kind of documentation related to the flow construct. It is intended to be "human readable" only and is not used by the system.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="initialState" default="started">
                    <xsd:annotation>
                        <xsd:documentation>
                            The initial state of the flow. Usually a flow is started automatically ("started"), but this attribute can be used to disable initial startup ("stopped").
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="started"/>
                            <xsd:enumeration value="stopped"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="flow" type="flowType">
        <xsd:annotation>
            <xsd:documentation>
                A pipeline of message processors processed using a given processingStrategy.
                Called when a new message is received from a message source, a flow-ref, or programmatically.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:simpleType name="flowProcessingStrategyType">
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of a globally configured processing strategy
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:restriction>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN">
                    <xsd:enumeration value="default">
                        <xsd:annotation>
                            <xsd:documentation>
                                This processing strategy uses the 'queued-asynchronous' strategy where possible, but if an event is synchronous it processes it synchronously rather than failing.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="synchronous">
                        <xsd:annotation>
                            <xsd:documentation>
                                Processes all message processors in the calling thread, waiting for any IO operations (e.g. http request) before continuing processing.  This is also known as 'blocking'.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="non-blocking">
                        <xsd:annotation>
                            <xsd:documentation>
                                Processes message processors in the calling thread, but supported non components will release the calling thread once a request has been sent.  Once a response is available the Flow will continue processing a worker thread.  In order to configure the thread pool used you can configure a custom 'non-blocking-processing-strategy' global element and reference it by name.
                                NOTE: This processing strategy is currently only supported with a  a single 'HTTP Listener or when there is no message source configured.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="asynchronous">
                        <xsd:annotation>
                            <xsd:documentation>
                                Uses a thread pool to process the pipeline of message processors asynchronously.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="queued-asynchronous">
                        <xsd:annotation>
                            <xsd:documentation>
                                Decouples the receiving of a new message from its processing using a queue.
                                The queue is polled and a thread pool is used to process the pipeline of message processors asynchronously.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="thread-per-processor">
                        <xsd:annotation>
                            <xsd:documentation>
                                EXPERIMENTAL: Uses a thread pool to process each message processors asynchronously. (each processor has it's own thread pool currently)
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="queued-thread-per-processor">
                        <xsd:annotation>
                            <xsd:documentation>
                                EXPERIMENTAL:  Decouples the processing of each message processor using a queue.
                                The queue is polled and use a thread pool to process each message processor asynchronously. (each processor has it's own thread pool currently)
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:enumeration>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>
    <xsd:complexType name="flowType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:sequence>
                    <xsd:element name="description" type="descriptionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                This can hold any kind of documentation related to the flow construct. It is intended to be "human readable" only and is not used by the system.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:group ref="messageSourceOrInboundEndpoint" minOccurs="0"/>
                    <xsd:choice minOccurs="1" maxOccurs="unbounded">
                        <xsd:group ref="messageProcessorOrOutboundEndpoint"/>
                        <xsd:element name="response">
                            <xsd:annotation>
                                <xsd:documentation>
                                    An outbound endpoint
                                </xsd:documentation>
                            </xsd:annotation>
                            <xsd:complexType>
                                <xsd:group ref="messageProcessorOrOutboundEndpoint" maxOccurs="unbounded"/>
                            </xsd:complexType>
                        </xsd:element>
                    </xsd:choice>
                    <xsd:element ref="legacy-abstract-exception-strategy" minOccurs="0"/>
                    <xsd:element ref="abstract-message-info-mapping" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The message info mapper used to extract key bits of the message information, such as Message ID or Correlation ID. these properties are used by some routers and this mapping information tells Mule where to get the information from in the current message.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="name" type="nonBlankString" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name used to identify this flow construct.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                 <xsd:attribute name="processingStrategy" use="optional" type="flowProcessingStrategyType">
                    <xsd:annotation>
                        <xsd:documentation>
                            Strategy used to process the configured message processors when exchange pattern is 'one-way'.
                            This attribute accepts either one of the enumerated strategies with default configuration options or a reference to a globally defined strategy.
                            If not specified, it will be taken from the defaultProcessingStrategy attribute of the &lt;configuration&gt; element. If that one
                            is not defined either, then the mule.default.processing.strategy system property will be checked. If that's not setup
                            either, then the value 'default' will be used
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="initialState" default="started">
                    <xsd:annotation>
                        <xsd:documentation>
                            The initial state of the flow. Usually a flow is started automatically ("started"), but this attribute can be used to disable initial startup ("stopped").
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:union>
                            <xsd:simpleType>
                                <xsd:restriction base="propertyPlaceholderType"/>
                            </xsd:simpleType>
                            <xsd:simpleType>
                                <xsd:restriction base="xsd:NMTOKEN">
                                    <xsd:enumeration value="started"/>
                                    <xsd:enumeration value="stopped"/>
                                </xsd:restriction>
                            </xsd:simpleType>
                        </xsd:union>
                    </xsd:simpleType>
                </xsd:attribute>
           </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--  Processing Strategies -->
    
    <xsd:element name="abstract-processing-strategy" type="processingStrategyType" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                The processing strategy to be used for processing a pipeline of message processors (e.g. in a Flow)
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="processingStrategyType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="name" type="nonBlankString" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name used to identify the processing strategy.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:element name="asynchronous-processing-strategy" type="asynchronousProcessingStrategy" substitutionGroup="abstract-processing-strategy">
        <xsd:annotation>
            <xsd:documentation>
               Processing strategy that uses a thread pool to process the pipeline of message processors asynchronously in a worker thread.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="asynchronousProcessingStrategy">
        <xsd:complexContent>
            <xsd:extension base="processingStrategyType">
                <xsd:attribute name="maxThreads" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The maximum number of threads that will be used when under load.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="minThreads" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The number of idle threads that will kept in the pool when there is no load.  
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attributeGroup ref="commonThreadPoolAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="queued-asynchronous-processing-strategy" type="queuedAsynchronousProcessingStrategy" substitutionGroup="abstract-processing-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Decouples the receiving of a new message from it's processing using a queue.
                The queue is polled and a thread pool is used to process the pipeline of message processors asynchronously in a worker thread.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="queuedAsynchronousProcessingStrategy">
        <xsd:complexContent>
            <xsd:extension base="asynchronousProcessingStrategy">
                <xsd:sequence>
                    <xsd:element ref="abstract-queue-store" minOccurs="0">
                    <xsd:annotation>
                        <xsd:documentation>
                            The queue store that stores the queue's elements.  If not specified, this will be the default-in-memory-queue-store.
                        </xsd:documentation>
                    </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="queueTimeout" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The timeout used when taking messages from the service queue.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maxQueueSize" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines the maximum number of messages that can be queued or '-1' for unlimited.  From 3.6 the default value used is four times the value of the 'maxThreads' attribute, previously the default value was '-1' (unlimited).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="thread-per-processor-processing-strategy" type="asynchronousProcessingStrategy" substitutionGroup="abstract-processing-strategy">
        <xsd:annotation>
            <xsd:documentation>
                EXPERIMENTAL: Uses a thread pool to process each message processors asynchronously in a worker thread. (each processor has it's own thread pool currently)
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="queued-thread-per-processor-processing-strategy" type="queuedAsynchronousProcessingStrategy" substitutionGroup="abstract-processing-strategy">
        <xsd:annotation>
            <xsd:documentation>
                EXPERIMENTAL:  Decouples the processing of each message processor using a queue. 
                The queue is polled and use a thread pool to process each message processor asynchronously in a worker thread. (each processor has it's own thread pool currently)
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="non-blocking-processing-strategy" type="nonBlockingProcessingStrategy" substitutionGroup="abstract-processing-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Processes message processors in the calling thread, but supported non-blocking components will release the calling thread once a request has been sent.  Once a response is available the Flow will continue processing a worker thread.
                NOTE: This processing strategy is currently only supported with a  a single 'HTTP Listener or when there is no message source configured.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="nonBlockingProcessingStrategy">
        <xsd:complexContent>
            <xsd:extension base="asynchronousProcessingStrategy"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-processing-strategy" type="customProcessingStrategy" substitutionGroup="abstract-processing-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Allows for the configuration of a custom processing strategy that implements 'org.mule.api.construct.PipelineProcessingStrategy'.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customProcessingStrategy">
        <xsd:complexContent>
            <xsd:extension base="processingStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:element name="flow-ref" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Allows a 'flow' to be referenced such that the message processing will continue in the referenced flow before returning.
                Message processing in the referenced 'flow' will occur within the context of the referenced flow and will therefore use its exception strategy etc.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractMessageProcessorType">
                    <xsd:attribute name="name" type="xsd:string" use="required"/>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="simple-service" type="simpleServiceType" substitutionGroup="abstract-flow-construct">
        <xsd:annotation>
            <xsd:documentation>
                Deprecated. Use pattern:simple-service instead
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:attributeGroup name="simpleServiceTypes">
        <xsd:attribute name="type">
            <xsd:annotation>
                <xsd:documentation>
                  Defines the type of simple service.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN">
                    <xsd:enumeration value="direct">
                      <xsd:annotation>
                        <xsd:documentation>
                          Pass the inbound messages unaltered to the component.
                        </xsd:documentation>
                      </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="jax-ws">
                      <xsd:annotation>
                        <xsd:documentation>
                          Expose a JAX-WS annoted component as a web service. The CXF module is required to have this working.
                        </xsd:documentation>
                      </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="jax-rs">
                      <xsd:annotation>
                        <xsd:documentation>
                          Expose a JAX-RS annoted component as a web service. The Jersey module is required to have this working.
                        </xsd:documentation>
                      </xsd:annotation>
                    </xsd:enumeration>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
    </xsd:attributeGroup>
    <xsd:complexType name="simpleServiceType">
        <xsd:annotation>
            <xsd:documentation>
                A simple request-response service, with no outbound router.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="baseFlowConstructType">
                <xsd:sequence>
                    <xsd:element ref="abstract-inbound-endpoint" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                The endpoint on which messages are received.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="abstract-component" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                The component that is invoked when incoming messages are received.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="legacy-abstract-exception-strategy" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="address" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The address on which this simple service is listening.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="endpoint-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The endpoint on which this simple service is listening.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="transformer-refs" type="xsd:NMTOKENS">
                    <xsd:annotation>
                        <xsd:documentation>
                            A list of the transformers that will be applied (in order) to the message before it is delivered to the component.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="responseTransformer-refs" type="xsd:NMTOKENS">
                    <xsd:annotation>
                        <xsd:documentation>
                            A list of the transformers that will be applied (in order) to the synchronous response before it is returned via the transport.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="component-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The component that is invoked when incoming messages are received.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="component-class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>
                            Specifies a component class. This is a shortcut that is equivalent to providing a 'prototype-object' element.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attributeGroup ref="simpleServiceTypes" />
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="bridge" type="bridgeType" substitutionGroup="abstract-flow-construct">
        <xsd:annotation>
            <xsd:documentation>
                Deprecated. Use pattern:bridge instead
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="bridgeType">
        <xsd:annotation>
            <xsd:documentation>
                A bridge with a single inbound endpoint and a single outbound endpoint.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="baseFlowConstructType">
                <xsd:sequence>
                    <xsd:element ref="abstract-inbound-endpoint" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                The endpoint on which messages are received.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                The endpoint to which messages are sent.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="legacy-abstract-exception-strategy" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="inboundAddress" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The address on which this bridge is listening.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="inboundEndpoint-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The endpoint on which this bridge is listening.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="outboundAddress" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The address to which messages are sent.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="outboundEndpoint-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The endpoint to which messages are sent.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="transformer-refs" type="xsd:NMTOKENS">
                    <xsd:annotation>
                        <xsd:documentation>
                            A list of the transformers that will be applied (in order) to the message before it is delivered to the destination endpoint.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="responseTransformer-refs" type="xsd:NMTOKENS">
                    <xsd:annotation>
                        <xsd:documentation>
                            A list of the transformers that will be applied (in order) to the synchronous response (if any) of the destination endpoint.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attributeGroup ref="allExchangePatterns" />
                <xsd:attribute name="transacted" type="xsd:boolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines if the bridge will consume its inbound messages and dispatch its outbound ones within a transaction.
                            Attempt will be made to automatically select the most appropriate transaction manager (including XA): for more control, use child endpoints.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="validator" type="validatorType" substitutionGroup="abstract-flow-construct">
        <xsd:annotation>
            <xsd:documentation>
                Deprecated. Use pattern:validator instead
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="validatorType">
        <xsd:annotation>
            <xsd:documentation>
                A validator with a single request-response inbound endpoint and a single outbound endpoint.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="baseFlowConstructType">
                <xsd:sequence>
                    <xsd:element ref="abstract-inbound-endpoint" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                The endpoint on which messages are received.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="abstract-filter" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                The filter to use to validate incoming message: accepted messages are considered valid.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                The endpoint to which messages are sent.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="legacy-abstract-exception-strategy" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="inboundAddress" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The address on which this bridge is listening.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="inboundEndpoint-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The endpoint on which this bridge is listening.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="validationFilter-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The filter to use to validate incoming message: accepted messages are considered valid.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="outboundAddress" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The address to which messages are sent.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="outboundEndpoint-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The endpoint to which messages are sent.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="ackExpression" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            An expression used to build the content of the response in case a valid message has been received.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="nackExpression" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            An expression used to build the content of the response in case an invalid message has been received.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="errorExpression" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            An expression used to build the content of the response in case an error occurs during the outbound dispatch.
                            The outbound endpoint's exchange pattern must be request-response if errorExpression is used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!-- Components                                              -->
    <!--==============================================================-->

    <xsd:element name="abstract-component" abstract="true" type="abstractComponentType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for a component element. A component is invoked when inbound messages are received by the service.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractComponentType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
            <xsd:group ref="interceptorGroup" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Interceptors that can be used to intercept component invocation.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:group>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="component" type="defaultJavaComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                A simple POJO (Plain Old Java Object) component that will be invoked by Mule when a message is received. The class or object instance to be used can be specified using a child object factory element, or via the 'class' attribute.  If the 'class' attribute is used, an object factory cannot be configured as well. Using the 'class' attribute is equivilant to using the propotype object factory ('prototype-object' child element).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="defaultJavaComponentType">
        <xsd:complexContent>
            <xsd:extension base="abstractComponentType">
                <xsd:sequence>
                    <xsd:group ref="entryPointResolvers">
                        <xsd:annotation>
                            <xsd:documentation>
                                Entry point resolvers that are used to determine how a message is passed to a component.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:group>
                    <xsd:element ref="abstract-object-factory" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Object factory used to obtain the object instance that will be used for the component implementation. The object factory is responsible for object creation and may implement different patterns, such as singleton or prototype, or look up an instance from other object containers.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="abstract-lifecycle-adapter-factory" minOccurs="0"/>
                    <xsd:element name="binding" type="pojoBindingType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                A binding associates a Mule endpoint with an injected Java interface. This is like using Spring to inject a bean, but instead of calling a method on the bean, a message is sent to an endpoint.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>
                            Specifies a component class. This is a shortcut that is equivalent to providing a 'prototype-object' element.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="pooled-component" type="pooledJavaComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                A pooled POJO (Plain Old Java Object) component that will be invoked by Mule when a message is received. The instance can be specified via a factory or a class.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="pooledJavaComponentType">
        <xsd:complexContent>
            <xsd:extension base="defaultJavaComponentType">
                <xsd:sequence>
                    <xsd:element ref="abstract-pooling-profile" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>Characteristics of the object pool.</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:complexType name="pojoBindingType">
        <xsd:sequence>
            <xsd:element ref="abstract-outbound-endpoint" minOccurs="1" maxOccurs="unbounded"/>
        </xsd:sequence>
        <xsd:attribute name="interface" use="required" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The interface to be injected. A proxy will be created that implements this interface by calling out to the endpoint.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="method" use="optional">
            <xsd:annotation>
                <xsd:documentation>
                    The method on the interface that should be used. This can be omitted if the interface has a single method.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="defaultComponentType">
        <xsd:complexContent>
            <xsd:extension base="abstractComponentType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- don't expose this, it's not needed -->
    <!-- xsd:element name="pass-through-component" type="defaultComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                The default, "do nothing" component.
                The message is simply transferred from inbound to outbound endpoints.
                This is the default and need not be specified.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element -->

    <xsd:element name="echo-component" type="defaultComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                Logs the message and returns the payload as the result.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="log-component" type="defaultComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                Logs the message content (or content length if it is a large message).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="null-component" type="defaultComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                Throws an exception if it receives a message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="static-component" type="staticComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                A service that will return static data as a result.  The data returned can be read from a file or can be embedded directly in the XML.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="staticComponentType">
        <xsd:complexContent>
            <xsd:extension base="abstractComponentType">
                <xsd:sequence>
                    <xsd:element name="return-data" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                Defines the data to return from the service once it has been invoked. The return data can be located in a file, which you specify using the {{file}} attribute (specify a resource on the classpath or on disk), or the return data can be embedded directly in the XML.
                            </xsd:documentation>
                        </xsd:annotation>
                        <xsd:complexType mixed="true">
                            <xsd:attribute name="file" type="xsd:string">
                                <xsd:annotation>
                                    <xsd:documentation>
                                        The location of a file to load. The file can point to a resource on the classpath or on disk.
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:attribute>
                        </xsd:complexType>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--   Transactions                                               -->
    <!--==============================================================-->

    <xsd:element name="abstract-transaction" abstract="true" type="abstractTransactionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for transaction elements. Transactions allow a series of operations to be grouped together.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="abstract-xa-transaction" abstract="true" type="abstractTransactionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for XA transaction elements. XA transactions allow a series of operations to be grouped together spanning different transports, such as JMS and JDBC.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="abstract-multi-transaction" abstract="true" type="abstractTransactionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for multi-transaction elements.
                Multi-transactions allow a series of operations to be grouped together spanning different
                transports, e.g. JMS and JDBC, but without the overhead of XA. The trade-off is that XA
                reliability guarantees aren't available, and services must be ready to handle duplicates.
                This is very similar to a 1.5 PC concept. EE-only feature.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractTransactionType">
        <xsd:attribute name="action" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    The type of action the transaction should take, one of the following:
                    NONE - Never participate in a transaction.
                    ALWAYS_BEGIN - Always start a new transaction when receiving a message. An exception will be thrown if a transaction already exists.
                    BEGIN_OR_JOIN - If a transaction is already in progress when a message is received, join the transaction if possible. Otherwise, start a new transaction.
                    ALWAYS_JOIN - Always expects a transaction to be in progress when a message is received. If there is no transaction, an exception is thrown.
                    JOIN_IF_POSSIBLE - Join the current transaction if one is available. Otherwise, no transaction is created.
                    NOT_SUPPORTED - Execute outside any existent transaction
                </xsd:documentation>
            </xsd:annotation>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN">
                    <xsd:enumeration value="NONE"/>
                    <xsd:enumeration value="ALWAYS_BEGIN"/>
                    <xsd:enumeration value="BEGIN_OR_JOIN"/>
                    <xsd:enumeration value="ALWAYS_JOIN"/>
                    <xsd:enumeration value="JOIN_IF_POSSIBLE"/>
                    <xsd:enumeration value="NOT_SUPPORTED"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute name="timeout" type="substitutableInt">
            <xsd:annotation>
                <xsd:documentation>
                    Timeout for the transaction (ms). This attribute is only taken into account in XA Transactions.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="baseTransactionType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransactionType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-transaction" type="customTransactionType" substitutionGroup="abstract-transaction">
        <xsd:annotation>
            <xsd:documentation>
                A user-defined or otherwise unsupported third-party transactions.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customTransactionType">
        <xsd:complexContent>
            <xsd:extension base="baseTransactionType">
                <xsd:attribute name="factory-class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>
                            A class that implements the TransactionFactory interface that will be instantiated and used to generate a transaction. This attribute and the 'factory-ref' attribute are mutually exclusive; one of the two is required.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="factory-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            A bean that implements the TransactionFactory interface that will be used to generate a transaction. This attribute and the 'factory-class' attribute are mutually exclusive; one of the two is required.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="xa-transaction" type="xaTransactionType" substitutionGroup="abstract-transaction">
        <xsd:annotation>
            <xsd:documentation>
                An XA transaction.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="xaTransactionType">
        <xsd:complexContent>
            <xsd:extension base="baseTransactionType">
                <xsd:attribute name="interactWithExternal" type="xsd:boolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            If this is set to "true", Mule interacts with transactions begun outside of Mule.  E.g. if an external transaction is active, then BEGIN_OR_JOIN wil join it, and ALWAYS_BEGIN will cause an exception to be thrown.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="transactionManagerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransactionManagerType">
                <xsd:attribute name="name" type="substitutableName" default="transactionManager" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            An optional name for the transaction manager. The default value is "transactionManager".
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="websphere-transaction-manager" type="transactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The WebSphere transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="jboss-transaction-manager" type="transactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The JBoss transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="jndiTransactionManagerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransactionManagerType">
                <xsd:sequence>
                    <xsd:element name="environment" type="mapType" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                The JNDI environment.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="weblogic-transaction-manager" type="jndiTransactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The WebLogic transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="jrun-transaction-manager" type="transactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The JRun transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="resin-transaction-manager" type="transactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The Resin transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="jndi-transaction-manager" substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                Retrieves a named transaction manager factory from JNDI.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="jndiTransactionManagerType">
                    <xsd:attribute name="jndiName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                The name of the manager factory to retrieve (such as java:/TransactionManager).
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="custom-transaction-manager" type="customTransactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                A user-implemented transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customTransactionManagerType">
        <xsd:complexContent>
            <xsd:extension base="jndiTransactionManagerType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The class to instantiate to create a transaction manager.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!--==============================================================-->
    <!--   Endpoint elements                                          -->
    <!--==============================================================-->

    <xsd:element name="endpoint" type="globalEndpointType" substitutionGroup="abstract-global-endpoint">
        <xsd:annotation>
            <xsd:documentation>
                A global endpoint, which acts as a template that can be used to construct an inbound or outbound endpoint elsewhere in the configuration by referencing the global endpoint name. Each transport implements its own endpoint element, with a more friendly syntax, but this generic element can be used with any transport by supplying the correct address URI. For example, "vm://foo" describes a VM transport endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="globalEndpointTypeWithoutExchangePattern">
        <xsd:complexContent>
            <xsd:extension base="abstractGlobalEndpointType">
                <xsd:group ref="defaultEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="globalEndpointType">
        <xsd:complexContent>
            <xsd:extension base="globalEndpointTypeWithoutExchangePattern">
                <xsd:attributeGroup ref="allExchangePatterns"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <!-- extend this type for endpoints that support XA transactions -->
    <xsd:complexType name="globalEndpointWithXaType">
        <xsd:complexContent>
            <xsd:extension base="abstractGlobalEndpointType">
                <xsd:group ref="defaultXaEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
                <xsd:attributeGroup ref="allExchangePatterns"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="inbound-endpoint" type="inboundEndpointType" substitutionGroup="abstract-inbound-endpoint">
        <xsd:annotation>
            <xsd:documentation>
                An inbound endpoint receives messages via the associated transport. As with global endpoints, each transport implements its own inbound endpoint element.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="inboundEndpointTypeWithoutExchangePattern">
        <xsd:complexContent>
            <xsd:extension base="abstractInboundEndpointType">
                <xsd:group ref="defaultEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="inboundEndpointType">
        <xsd:complexContent>
            <xsd:extension base="inboundEndpointTypeWithoutExchangePattern">
                <xsd:attributeGroup ref="allExchangePatterns"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <!-- extend this type for endpoints that support XA transactions -->
    <xsd:complexType name="inboundEndpointWithXaType">
        <xsd:complexContent>
            <xsd:extension base="abstractInboundEndpointType">
                <xsd:group ref="defaultXaEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
                <xsd:attributeGroup ref="allExchangePatterns"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-scheduler" abstract="true" type="abstractSchedulerType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for shedulers
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractSchedulerType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="fixedSchedulerType">
        <xsd:complexContent>
            <xsd:extension base="abstractSchedulerType">
                <xsd:attribute name="frequency" type="substitutableLong" default="1000">
                    <xsd:annotation>
                        <xsd:documentation>
                            Polling frequency in milliseconds. Default frequency is 1000ms (1s).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="timeUnit" default="MILLISECONDS" type="timeUnitType">
                    <xsd:annotation>
                        <xsd:documentation>
                            The time unit for the frequency value
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="startDelay" type="substitutableLong" default="0">
                    <xsd:annotation>
                        <xsd:documentation>
                            The delay time in time units that sheduler needs to wait before start
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="fixed-frequency-scheduler" type="fixedSchedulerType" substitutionGroup="abstract-scheduler"/>

    <xsd:element name="poll" type="pollInboundEndpointType" substitutionGroup="abstract-message-source">
        <xsd:annotation>
            <xsd:documentation>
                Polls the nested message processor for new messages
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="pollInboundEndpointType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageSourceType">
                <xsd:sequence>
                    <xsd:element ref="abstract-scheduler" minOccurs="0" maxOccurs="1"/>
                    <xsd:element ref="abstract-poll-override" minOccurs="0" maxOccurs="1"/>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint"/>
                </xsd:sequence>
                <xsd:attribute name="frequency"  type="substitutableLong" default="1000">
                    <xsd:annotation>
                        <xsd:documentation>
                            Polling frequency in milliseconds. Default frequency is 1000ms (1s). Deprecated since 3.5.0. use fixed-frequency-scheduler instead
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="outbound-endpoint" type="outboundEndpointType" substitutionGroup="abstract-outbound-endpoint">
        <xsd:annotation>
            <xsd:documentation>
                An outbound endpoint sends messages via the associated transport. As with global endpoints, each transport implements its own outbound endpoint element.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="outboundEndpointTypeWithoutExchangePattern">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundEndpointType">
                <xsd:group ref="defaultEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="outboundEndpointType">
        <xsd:complexContent>
            <xsd:extension base="outboundEndpointTypeWithoutExchangePattern">
                <xsd:attributeGroup ref="allExchangePatterns"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="outboundEndpointWithXaType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundEndpointType">
                <xsd:group ref="defaultXaEndpointElements"/>
                <xsd:attributeGroup ref="allExchangePatterns"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="response">
        <xsd:complexType>
            <xsd:sequence>
                <xsd:group ref="endpointMessageProcessorElements" minOccurs="1" maxOccurs="unbounded"/>
            </xsd:sequence>
        </xsd:complexType>
    </xsd:element>

    <!-- these include option/repeats - should be embedded once -->
        <!-- these include option/repeats - should be embedded once -->
    <xsd:group name="commonDefaultEndpointElements">
        <xsd:sequence>
            <xsd:group ref="endpointMessageProcessorElements" minOccurs="0" maxOccurs="unbounded"/>
            <xsd:element ref="response" minOccurs="0"/>
            <xsd:element ref="abstract-redelivery-policy" minOccurs="0"/>
            <xsd:element ref="abstract-transaction" minOccurs="0"/>
        </xsd:sequence>
    </xsd:group>

    <xsd:group name="defaultEndpointElements">
        <xsd:sequence>
            <xsd:group ref="commonDefaultEndpointElements"/>
            <xsd:element ref="abstract-multi-transaction" minOccurs="0"/>
            <xsd:group ref="propertiesGroup"/>
        </xsd:sequence>
    </xsd:group>

    <xsd:group name="defaultXaEndpointElements">
        <xsd:sequence>
            <xsd:group ref="commonDefaultEndpointElements"/>
            <xsd:element ref="abstract-xa-transaction" minOccurs="0"/>
            <xsd:group ref="propertiesGroup"/>
        </xsd:sequence>
    </xsd:group>

    <xsd:group name="endpointMessageProcessorElements">
        <xsd:choice>
            <xsd:element ref="abstract-transformer" />
            <xsd:element ref="abstract-filter" />
            <xsd:element ref="abstract-security-filter"/>
            <xsd:element ref="abstract-intercepting-message-processor"/>
            <xsd:element ref="abstract-observer-message-processor"/>
            <xsd:element ref="processor"/>
            <xsd:element ref="custom-processor"/>
            <xsd:element ref="abstract-mixed-content-message-processor"/>
        </xsd:choice>
    </xsd:group>

    <xsd:element name="abstract-security-filter" abstract="true" type="abstractSecurityFilterType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for security filter elements, which control access to the system.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractSecurityFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="username-password-filter" type="usernamePasswordFilterType" substitutionGroup="abstract-security-filter">
        <xsd:annotation>
            <xsd:documentation>
                Authenticates a message based on username and password expressions.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="usernamePasswordFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractSecurityFilterType">
                <xsd:attribute name="username" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            A Mule expression which extracts the username from the message. Defaults to #[header:inbound:username].
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="password" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            A Mule expression which extracts the password from the message. Defaults to #[header:inbound:password].
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-security-filter" type="customSecurityFilterType" substitutionGroup="abstract-security-filter">
        <xsd:annotation>
            <xsd:documentation>
                Allows developers to configure custom security filters
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="customSecurityFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractSecurityFilterType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="commonThreadPoolAttributes">
        <xsd:attribute name="threadTTL" type="substitutableInt">
            <xsd:annotation>
                <xsd:documentation>
                    Determines how long an inactive thread is kept in the pool before being discarded.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="poolExhaustedAction">
            <xsd:annotation>
                <xsd:documentation>
                    When the maximum pool size or queue size is bounded, this value determines how to handle incoming tasks. Possible values are: WAIT (wait until a thread becomes available; don't use this value if the minimum number of threads is zero, in which case a thread may never become available), DISCARD (throw away the current request and return), DISCARD_OLDEST (throw away the oldest request and return), ABORT (throw a RuntimeException), and RUN (the default; the thread making the execute request runs the task itself, which helps guard against lockup).
                </xsd:documentation>
            </xsd:annotation>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN">
                    <xsd:enumeration value="WAIT"/>
                    <xsd:enumeration value="DISCARD"/>
                    <xsd:enumeration value="DISCARD_OLDEST"/>
                    <xsd:enumeration value="ABORT"/>
                    <xsd:enumeration value="RUN"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute name="threadWaitTimeout" type="substitutableInt">
            <xsd:annotation>
                <xsd:documentation>
                    How long to wait in milliseconds when the pool exhausted action is WAIT. If the value is zero or negative, it will wait indefinitely.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="maxBufferSize" type="substitutableInt">
            <xsd:annotation>
                <xsd:documentation>
                    Determines how many requests are queued when the pool is at maximum usage capacity and the pool exhausted action is WAIT. The buffer is used as an overflow.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>


    <xsd:attributeGroup name="defaultEndpointAttributes">
        <xsd:attributeGroup ref="restrictedEndpointAttributes"/>
        <!-- these next two attributes are mutually exclusive and one is required.
             but there is no way to define this in a schema... -->
        <!-- endpoint references - dynamically checked to make sure not top level -->
        <xsd:attribute name="ref" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    A reference to a global endpoint, which is used as a template to construct this endpoint. A template fixes the address (protocol, path, host, etc.), and may specify initial values for various properties, but further properties can be defined locally (as long as they do not change the address in any way).
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <!-- explicit or global endpoints -->
        <xsd:attribute name="address" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The generic address for this endpoint. If this attribute is used, the protocol must be specified as part of the URI. Alternatively, most transports provide their own attributes for specifying the address (path, host, etc.). Note that the address attribute cannot be combined with 'ref' or with the transport-provided alternative attributes.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="restrictedEndpointAttributes">
        <xsd:attributeGroup ref="mimeTypeAttributes"/>
        <xsd:attribute name="responseTimeout" type="substitutableInt">
            <xsd:annotation>
                <xsd:documentation>
                    The timeout for a response if making a synchronous endpoint call
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="encoding" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    String encoding used for messages.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="connector-ref" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The name of the connector associated with this endpoint. This must be specified if more than one connector is defined for this transport.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="transformer-refs" type="xsd:NMTOKENS">
            <xsd:annotation>
                <xsd:documentation>
                    A list of the transformers that will be applied (in order) to the message before it is delivered to the component.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="responseTransformer-refs" type="xsd:NMTOKENS">
            <xsd:annotation>
                <xsd:documentation>
                    A list of the transformers that will be applied (in order) to the synchronous response before it is returned via the transport.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="disableTransportTransformer" type="substitutableBoolean" use="optional">
            <xsd:annotation>
                <xsd:documentation>
                    Don't use the default inbound/outbound/response transformer which corresponds to this endpoint's transport, if any.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:complexType name="endpointRefType">
        <xsd:attribute name="address" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The destination address for a reply message.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="ref" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The reference name of a global endpoint to use. If this EndpointRef will be associated to a message such as a Reply-To address, this endpoint ref has to be available on the remote Mule instance that reads the Reply-To address.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:attributeGroup name="allExchangePatterns">
        <xsd:attribute name="exchange-pattern">
            <xsd:annotation>
                <xsd:documentation>
                </xsd:documentation>
            </xsd:annotation>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN">
                    <xsd:enumeration value="one-way"/>
                    <xsd:enumeration value="request-response"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
    </xsd:attributeGroup>
    <xsd:attributeGroup name="oneWayOnlyExchangePattern">
        <xsd:attribute name="exchange-pattern">
            <xsd:annotation>
                <xsd:documentation>
                </xsd:documentation>
            </xsd:annotation>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN">
                    <xsd:enumeration value="one-way"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
    </xsd:attributeGroup>


    <!--==============================================================-->
    <!--   Filter elements                                            -->
    <!--==============================================================-->

    <xsd:element name="filter" type="refFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that is defined elsewhere (at the global level, or as a Spring bean).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="refFilterType">
        <xsd:complexContent>
            <xsd:extension base="commonFilterType">
                <xsd:attribute name="ref" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the filter to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="not-filter" type="unitaryFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                Inverts the enclosed filter. For example, if the filter would normally return true for a specific message, it will now return false, and vice versa.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="unitaryFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-filter"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="and-filter" type="collectionFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                Returns true only if all the enclosed filters return true.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="or-filter" type="collectionFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                Returns true if any of the enclosed filters returns true.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="collectionFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-filter" minOccurs="2" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="wildcard-filter" type="wildcardFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches string messages against wildcards. It performs matches with "*", for example, "jms.events.*" would catch "jms.events.customer" and "jms.events.receipts". This filter accepts a comma-separated list of patterns, so more than one filter pattern can be matched for a given argument: "jms.events.*, jms.actions.*" will match "jms.events.system" and "jms.actions" but not "jms.queue".
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="wildcardFilterType">
        <xsd:complexContent>
            <xsd:extension base="caseSensitivePatternFilterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="expression-filter" type="expressionFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that can evaluate a range of expressions. It supports some base expression types such as header, payload (payload type), regex, and wildcard.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="expressionFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:attribute name="evaluator" type="expressionFilterEvaluators" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>The expression evaluator to use. The expression filter supports some types such as header, payload, exception, wildcard, and regex, that are built-in filters not registered with the ExpressionEvaluatorManager. All others are registered with the ExpressionEvaluatorManager. Where XPath, bean, and ONGL are used, the expression should be a boolean expression.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="expression" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>The expression that will be evaluated. This should always be a boolean expression. The syntax of the expression will be determined by the expression language being used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="customEvaluator" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>Must be set if the evaluator is set to custom. The custom evaluator must be registered with the ExpressionEvaluatorManager if it is to be used here.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="nullReturnsTrue" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>Whether the filter should return true if the specified expression returns null.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:element name="regex-filter" type="regexFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches string messages against a regular expression. The Java regular expression engine (java.util.regex.Pattern) is used.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="regexFilterType">
        <xsd:complexContent>
            <xsd:extension base="patternFilterType">
                <xsd:attribute name="flags" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Comma-separated list of flags for compiling the pattern. Valid values are CASE_INSENSITIVE, MULTILINE, DOTALL, UNICODE_CASE and CANON_EQ.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="patternFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:attribute name="pattern" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The property name and optionally a value to use when matching. If the expression is just a property name, the filter will check that the property exists. Users can also use '=' and '!=' to determine a specific value for a property.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="value" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Value to validate.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="message-property-filter" type="scopedPropertyFilterType"
                 substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches properties on a message. This can be very useful, as the message properties represent all the meta information about the message from the underlying transport, so for a message received over HTTP, you can check for HTTP headers and so forth. The pattern should be expressed as a key/value pair, such as "propertyName=value". If you want to compare more than one property, you can use the logic filters for And, Or, and Not expressions. By default, the comparison is case sensitive, which you can override with the 'caseSensitive' property.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="scopedPropertyFilterType">
        <xsd:complexContent>
            <xsd:extension base="caseSensitivePatternFilterType">
                <xsd:attribute name="scope" default="outbound">
                    <xsd:annotation>
                        <xsd:documentation>
                            Property scope to lookup the value from (default: outbound)
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="inbound"/>
                            <xsd:enumeration value="invocation"/>
                            <xsd:enumeration value="outbound"/>
                            <xsd:enumeration value="session"/>
                            <xsd:enumeration value="application"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="caseSensitivePatternFilterType">
        <xsd:complexContent>
            <xsd:extension base="patternFilterType">
                <xsd:attribute name="caseSensitive" type="substitutableBoolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            If false, the comparison ignores case.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="exception-type-filter" type="typeFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches the type of an exception.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="payload-type-filter" type="typeFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches the type of the payload.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="typeFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:attribute name="expectedType" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The expected class used in the comparison.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-filter" type="customFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A user-implemented filter.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the Filter interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--   Interceptor elements                                       -->
    <!--==============================================================-->
    <xsd:element name="abstract-interceptor-stack" abstract="true" type="abstractInterceptorStackType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for interceptor stack elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractInterceptorStackType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:sequence maxOccurs="unbounded">
                    <xsd:element ref="abstract-interceptor"/>
                </xsd:sequence>
                <xsd:attribute name="name" type="nonBlankString" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name used to identify this interceptor stack.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="interceptor-stack" type="abstractInterceptorStackType" substitutionGroup="abstract-interceptor-stack"/>


    <xsd:element name="abstract-interceptor" abstract="true" type="abstractInterceptorType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for an interceptor element.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractInterceptorType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType" />
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:group name="interceptorGroup">
        <xsd:sequence>
            <xsd:choice maxOccurs="unbounded">
                <xsd:element ref="abstract-interceptor"/>
                <xsd:element name="interceptor-stack" type="refInterceptorStackType">
                    <xsd:annotation>
                        <xsd:documentation>
                            A reference to a stack of intereceptors defined globally.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:element>
            </xsd:choice>
        </xsd:sequence>
    </xsd:group>

    <xsd:complexType name="refInterceptorStackType">
        <xsd:attribute name="ref" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    The name of the interceptor stack to use.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="timer-interceptor" type="abstractInterceptorType" substitutionGroup="abstract-interceptor">
        <xsd:annotation>
            <xsd:documentation>
                The timer interceptor (ported from 1.x).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="logging-interceptor" type="abstractInterceptorType" substitutionGroup="abstract-interceptor">
        <xsd:annotation>
            <xsd:documentation>
                The logging interceptor (ported from 1.x).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="custom-interceptor" type="customInterceptorType" substitutionGroup="abstract-interceptor">
        <xsd:annotation>
            <xsd:documentation>
                A user-implemented interceptor.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customInterceptorType">
        <xsd:complexContent>
            <xsd:extension base="abstractInterceptorType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the Interceptor interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- security filters -->

    <xsd:element name="encryption-security-filter" type="encryptionSecurityFilterType"
                 substitutionGroup="abstract-security-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that provides password-based encyption.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="encryptionSecurityFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractSecurityFilterType">
                <xsd:attribute name="strategy-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the encryption strategy to use. This should be configured using the 'password-encryption-strategy' element, inside a 'security-manager' element at the top level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!--==============================================================-->
    <!--   Transformer elements                                       -->
    <!--==============================================================-->

    <xsd:element name="transformer" type="refTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A reference to a transformer defined elsewhere.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="refTransformerType">
        <xsd:complexContent>
            <xsd:extension base="commonTransformerType">
                <xsd:attribute name="ref" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the transformer to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="auto-transformer" type="abstractTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that uses the transform discovery mechanism to convert the message payload. This transformer works much better when transforming custom object types rather than Java types, because there is less chance for ambiguity.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="custom-transformer" type="customTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A user-implemented transformer.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the Transformer interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="message-properties-transformer" type="messagePropertiesTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that can add, delete or rename message properties.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="messagePropertiesTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element name="delete-message-property" type="keyType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Delete message properties matching a regular expression or wildcard.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="add-message-property" type="propertyWithDataType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Add a message property.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="rename-message-property" type="keyValueType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Rename a message property.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="add-message-properties" type="mapType" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                Add a set of message properties.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:choice>
                <xsd:attribute name="overwrite" type="substitutableBoolean" use="optional" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            If false, a property is not added if the message already contains a property with that name.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="scope" use="optional" default="outbound">
                    <xsd:annotation>
                        <xsd:documentation>
                            Property scope to/from which properties are added/removed.  The scope determines the lifespan of the properties. Default scope is outbound.
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="invocation"/>
                            <xsd:enumeration value="outbound"/>
                            <xsd:enumeration value="session"/>
                            <xsd:enumeration value="application"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="abstractAddPropertyTransformerType">
        <xsd:complexContent>
            <xsd:extension base="commonMessagePartTransformerType">
                <xsd:attributeGroup ref="mimeTypeAttributes">
                    <xsd:annotation>
                        <xsd:documentation>
                            The mime type of the value assigned to the property
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attributeGroup>
                <xsd:attribute name="encoding" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The encoding of the value assigned to the property
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="set-property" type="setPropertyType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that adds outbound message properties.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="setPropertyType">
        <xsd:complexContent>
            <xsd:extension base="abstractAddPropertyTransformerType">
                <xsd:attribute name="propertyName" type="nonEmptyAttributeType" use="required"/>
                <xsd:attribute name="value" type="attributeType" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="remove-property" type="removePropertyType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that remove outbound message properties by name or regular expression.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="removePropertyType">
        <xsd:complexContent>
            <xsd:extension base="commonMessagePartTransformerType">
                <xsd:attribute name="propertyName" type="attributeType" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="copy-properties" type="copyPropertiesType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that copy properties from inbound to outbound scope by name or regular expression.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="copyPropertiesType">
        <xsd:complexContent>
            <xsd:extension base="commonMessagePartTransformerType">
                <xsd:attribute name="propertyName" type="attributeType" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="set-variable" type="setVariableType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that adds variables.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="setVariableType">
        <xsd:complexContent>
            <xsd:extension base="abstractAddPropertyTransformerType">
                <xsd:attribute name="variableName" type="nonEmptyAttributeType" use="required"/>
                <xsd:attribute name="value" type="attributeType" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="commonMessagePartTransformerType">
        <xsd:complexContent>
            <xsd:extension base="commonTransformerType">
                <xsd:attribute name="name" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the transformer so that other elements can reference it. Required if the transformer is defined at the global level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="remove-variable" type="removeVariableType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that remove variables by name or regular expression.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="removeVariableType">
        <xsd:complexContent>
            <xsd:extension base="commonMessagePartTransformerType">
                <xsd:attribute name="variableName" type="attributeType" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="set-session-variable" type="setVariableType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that adds session variables.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="remove-session-variable" type="removeVariableType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that remove session variables by name or regular expression.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="set-attachment" type="setAttachmentType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that adds an attachment to the outbound scope.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="setAttachmentType">
        <xsd:complexContent>
            <xsd:extension base="commonMessagePartTransformerType">
                <xsd:attribute name="attachmentName" type="attributeType" use="required"/>
                <xsd:attribute name="value" type="attributeType" use="required"/>
                <xsd:attribute name="contentType" type="attributeType" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="remove-attachment" type="removeAttachmentType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that removes an attachment in the outbound scope.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="removeAttachmentType">
        <xsd:complexContent>
            <xsd:extension base="commonMessagePartTransformerType">
                <xsd:attribute name="attachmentName" type="attributeType" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="copy-attachments" type="copyAttachmentType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that copy inbound attachment to outbound attachment scope by name or regular expression.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="copyAttachmentType">
        <xsd:complexContent>
            <xsd:extension base="commonMessagePartTransformerType">
                <xsd:attribute name="attachmentName" type="attributeType" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:element name="base64-encoder-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that base64 encodes a string or byte array message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="base64-decoder-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that base64 decodes a message to give an array of bytes.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="xml-entity-encoder-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that encodes a string using XML entities.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="xml-entity-decoder-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that decodes a string containing XML entities.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="gzip-compress-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that compresses a byte array using gzip.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="gzip-uncompress-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that uncompresses a byte array using gzip.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="byte-array-to-hex-string-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a byte array to a string of hexadecimal digits.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="hex-string-to-byte-array-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a string of hexadecimal digits to a byte array.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="byte-array-to-object-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a byte array to an object (either deserializing or converting to a string).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="object-to-byte-array-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that serializes all objects except strings (which are converted using getBytes()).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="object-to-string-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that gives a human-readable description of various types (useful for debugging).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="byte-array-to-serializable-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a byte array to an object (deserializing the object).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="serializable-to-byte-array-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts an object to a byte array (serializing the object).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="byte-array-to-string-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a byte array to a string.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="string-to-byte-array-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a string to a byte array.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="map-to-bean-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                Creates and object of type @return-class and populates values of a {{java.util.Map}} as bean properties on the object.
                The bean class name can also be passed in as a property on the Map (which gets removed once read).  The {{MapToBean.CLASS_PROPERTY}} 'className' should be set as a fully qualified class name string.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="bean-to-map-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                Conversts a simple bean object to a Map. every property on the bean will become an entry in the result {{java.util.Map}}. Note that only exposed bean properties with getter and setter methods will be added to the map.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="append-string-transformer" type="appendStringTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that appends a string to a string payload.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="appendStringTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:attribute name="message" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The string to append.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="parse-template" type="parseTemplateTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that parses a template in a given location
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="parseTemplateTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:attribute name="location" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The location of the template. The order in which the transformer will attempt to load the file are: from the file system, from a URL or from the classpath.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="set-payload" type="setPayloadTransformerType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that sets the paylaod with the provided value
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="setPayloadTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType">
                <xsd:attribute name="name" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the message processor so that other elements can reference it. Required if the message processor is defined at the global level.
                            Deprecated. Provided only to maintain backwards compatibility at XML level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="returnClass" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Deprecated. Provided only to maintain backwards compatibility at XML level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="ignoreBadInput" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            Deprecated. Provided only to maintain backwards compatibility at XML level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attributeGroup ref="mimeTypeAttributes">
                    <xsd:annotation>
                        <xsd:documentation>
                            The mime type of the value assigned to the payload
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attributeGroup>
                <xsd:attribute name="encoding" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The encoding of the value assigned to the payload
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="value" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The value to be set on the payload. Supports expressions.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="encrypt-transformer" type="encryptionTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that encrypts a message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="decrypt-transformer" type="encryptionTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that decrypts a message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="encryptionTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:attribute name="strategy-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the encryption strategy to use. This should be configured using the password-encryption-strategy element, inside a security-manager element at the top level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="bean-builder-transformer" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that uses expressions to configure a simple bean object.  The user can specify a bean class or factory to create and one or more expressions that are used to configure properties on the bean.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractTransformerType">
                    <xsd:sequence minOccurs="1" maxOccurs="unbounded">
                        <xsd:element name="bean-property">
                            <xsd:complexType>
                                <xsd:attribute name="property-name" type="xsd:string" use="required">
                                    <xsd:annotation>
                                        <xsd:documentation>
                                            The name of the bean property
                                        </xsd:documentation>
                                    </xsd:annotation>
                                </xsd:attribute>
                                <xsd:attributeGroup ref="expressionAttributes"/>
                                <xsd:attribute name="optional" type="substitutableBoolean" use="optional">
                                    <xsd:annotation>
                                        <xsd:documentation>If the expression evaluates to null, whether to continue to the next expression without error.
                                        </xsd:documentation>
                                    </xsd:annotation>
                                </xsd:attribute>
                            </xsd:complexType>
                        </xsd:element>
                    </xsd:sequence>
                    <xsd:attribute name="beanClass" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                The bean class to create
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="beanFactory-ref" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                A Bean factory to use when creating the bean object.  The factory must implement {{org.mule.api.object.ObjectFactory}}.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="expression-transformer" type="expressionTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that evaluates one or more expressions on the current message. Each expression equates to a parameter in the return message. The return message for two or more expressions will be an Object[].
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="expressionTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:sequence minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="return-argument">
                        <xsd:annotation>
                            <xsd:documentation>If all expressions return null or NullPayload on this transformer, this flag will cause the source payload to be returned without modification.
                            </xsd:documentation>
                        </xsd:annotation>
                        <xsd:complexType>
                            <xsd:attributeGroup ref="expressionAttributes"/>
                        <!-- 
                         -->
                            <xsd:attribute name="optional" type="substitutableBoolean" use="optional">
                                <xsd:annotation>
                                    <xsd:documentation>If the expression evaluates to null, specifies whether to continue to the next expression without error.
                                    </xsd:documentation>
                                </xsd:annotation>
                            </xsd:attribute>
                        </xsd:complexType>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attributeGroup ref="optionalExpressionAttributes"/>
                <xsd:attribute name="returnSourceIfNull" type="xsd:boolean" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>If all expressions return null on this transformer, this flag will cause the source payload to be returned without modification.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="standardExpressionEvaluators">
        <xsd:restriction base="substitutableName">
            <xsd:enumeration value="attachment"/>
            <xsd:enumeration value="attachments"/>
            <xsd:enumeration value="attachments-list"/>
            <xsd:enumeration value="bean"/>
            <xsd:enumeration value="endpoint"/>
            <xsd:enumeration value="exception-type"/>
            <xsd:enumeration value="function"/>
            <xsd:enumeration value="groovy"/>
            <xsd:enumeration value="header"/>
            <xsd:enumeration value="headers"/>
            <xsd:enumeration value="headers-list"/>
            <xsd:enumeration value="json"/>
            <xsd:enumeration value="json-node"/>
            <xsd:enumeration value="jxpath"/>
            <xsd:enumeration value="map-payload"/>
            <xsd:enumeration value="message"/>
            <xsd:enumeration value="mule"/>
            <xsd:enumeration value="ognl"/>
            <xsd:enumeration value="payload"/>
            <xsd:enumeration value="process"/>
            <xsd:enumeration value="regex"/>
            <xsd:enumeration value="string"/>
            <xsd:enumeration value="variable"/>
            <xsd:enumeration value="xpath"/>
            <xsd:enumeration value="xpath2"/>
            <xsd:enumeration value="xpath-node"/>
            <xsd:enumeration value="custom"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="expressionFilterEvaluators">
        <xsd:restriction base="substitutableName">
            <xsd:enumeration value="header"/>
            <xsd:enumeration value="payload-type"/>
            <xsd:enumeration value="exception-type"/>
            <xsd:enumeration value="wildcard"/>
            <xsd:enumeration value="regex"/>
            <xsd:enumeration value="ognl"/>
            <xsd:enumeration value="xpath"/>
            <xsd:enumeration value="jxpath"/>
            <xsd:enumeration value="groovy"/>
            <xsd:enumeration value="bean"/>
            <xsd:enumeration value="custom"/>
            <xsd:enumeration value="registry"/>
            <xsd:enumeration value="variable"/>
        </xsd:restriction>
    </xsd:simpleType>


    <xsd:simpleType name="whenExpressionEvaluators">
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="standardExpressionEvaluators"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="substitutableName">
                    <xsd:enumeration value="payload-type"/>
                    <xsd:enumeration value="exception-type"/>
                    <xsd:enumeration value="wildcard"/>
                    <xsd:enumeration value="regex"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>


    <xsd:simpleType name="standardExpressionEnrichers">
        <xsd:restriction base="substitutableName">
            <xsd:enumeration value="header"/>
            <xsd:enumeration value="custom"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:attributeGroup name="expressionAttributes">
        <xsd:attribute name="evaluator" use="optional" type="standardExpressionEvaluators">
            <xsd:annotation>
                <xsd:documentation>The expression evaluator to use. Expression evaluators must be registered with the ExpressionEvaluatorManager before they can be used. Using the custom evaluator allows you to define your own evaluator with the 'custom-evaluator' attribute. Note that some evaluators such as xpath, groovy, and bean are loaded from other Mule modules (XML and Scripting, respectively). These modules must be on your classpath before the evaluator can be used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="expression" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation>The expression to evaluate. The syntax of this attribute changes depending on the evaluator being used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="custom-evaluator" type="substitutableName" use="optional">
            <xsd:annotation>
                <xsd:documentation>The name of the custom evaluator to use. This attribute is only used when the 'evaluator' attribute is set to "custom". You can plug in your own expression evaluators by registering them with the ExpressionEvaluatorManager.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="optionalExpressionAttributes">
        <xsd:attribute name="evaluator" type="standardExpressionEvaluators">
            <xsd:annotation>
                <xsd:documentation>The expression evaluator to use. Expression evaluators must be registered with the ExpressionEvaluatorManager before they can be used. Using the custom evaluator allows you to define your own evaluator with the 'custom-evaluator' attribute. Note that some evaluators such as xpath, groovy, and bean are loaded from other Mule modules (XML and Scripting, respectively). These modules must be on your classpath before the evaluator can be used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="expression" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>The expression to evaluate. The syntax of this attribute changes depending on the evaluator being used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="custom-evaluator" type="substitutableName">
            <xsd:annotation>
                <xsd:documentation>The name of the custom evaluator to use. This attribute is only used when the 'evaluator' attribute is set to "custom". You can plug in your own expression evaluators by registering them with the ExpressionEvaluatorManager.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:element name="value-extractor-transformer" type="valueExtractorTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                Extracts values from a given source using regular expressions and uses that values to enrich the mule message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="valueExtractorTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:sequence>
                    <xsd:element name="extract" type="extractValueExtractorTemplateType" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="source" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            An evaluator expression used to extract the value that will be matched against each regular expression. If an expression is not specified then the payload of the message is used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="extractValueExtractorTemplateType">
        <xsd:attributeGroup ref="valueExtractorTemplateAttributes"/>
    </xsd:complexType>

    <xsd:attributeGroup name="valueExtractorTemplateAttributes">
        <xsd:attribute name="pattern" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    A regular expression used to match against a source value. The regular expression should contain a capture group which value will be returned.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="target" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    The enricher expression used to enrich the current message with the result the processing of the regular expression.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="failIfNoMatch" type="substitutableBoolean" default="true">
            <xsd:annotation>
                <xsd:documentation>
                    Determines if there should be an error in case the pattern is not matched by the source value.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="defaultValue" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation>
                    The default value used to enrich the message when the source value does not match the pattern. Useful only when failIfNoMatch is false.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <!--==============================================================-->
    <!--   Shared elements                                             -->
    <!--==============================================================-->

    <xsd:element name="queue-profile" type="queueProfileType" substitutionGroup="abstract-queue-profile">
        <xsd:annotation>
            <xsd:documentation>
                Specifies the properties of an internal Mule queue. Internal queues are used to queue messages for each component managed by Mule.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="queueProfileType">
        <xsd:complexContent>
            <xsd:extension base="abstractQueueProfileType">
                <xsd:sequence>
                    <xsd:element ref="abstract-queue-store" minOccurs="0">
                    <xsd:annotation>
                        <xsd:documentation>
                            The queue store that stortes the queue's elements.  If not specified, this will be the default-in-memory-queue-store.
                        </xsd:documentation>
                    </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="maxOutstandingMessages" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines the maximum number of messages that can be queued.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-security-manager" type="abstractSecurityManagerType" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                A security manager is a container for security providers. More than one security manager may be configured; each contains providers from a particular module and has that module type. This element is abstract - a security-related module or transport will provide a suitable implementation.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="abstractSecurityManagerType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:annotation>
                    <xsd:documentation>
                        An empty holder that can be extended by modules that want to provide security managers. Typically it will contain elements called 'module:type-security-provider', which extend securityProviderType where "module" might be "spring-security" and "type" might de "delegate", for example. It can also contain encryption strategies, which should follow a similar scheme and extend encryptionStrategyType.
                    </xsd:documentation>
                </xsd:annotation>
                <xsd:attribute name="id" default="_muleSecurityManager"/>
                <xsd:attribute name="name" default="_muleSecurityManager"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="security-manager" type="securityManagerType" substitutionGroup="abstract-security-manager">
        <xsd:annotation>
            <xsd:documentation>
                The default security manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="securityManagerType">
        <xsd:annotation>
            <xsd:documentation>
                The default security manager (type 'defaultSecurityManagerType') provides basic support for security functions. Other modules (JAAS, PGP, Spring Security) provide more advanced functionality.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractSecurityManagerType">
                <xsd:sequence>
                    <xsd:element name="custom-security-provider" type="customSecurityProviderType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                A custom implementation of SecurityProvider.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="custom-encryption-strategy" type="customEncryptionStrategyType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                A custom implementation of EncryptionStrategy.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="secret-key-encryption-strategy" type="secretKeyEncryptionStrategyType"
                                 minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Provides secret key-based encryption using JCE.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="password-encryption-strategy" type="passwordEncryptionStrategyType"
                                 minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Provides password-based encryption using JCE. Users must specify a password and optionally a salt and iteration count as well. The default algorithm is PBEWithMD5AndDES, but users can specify any valid algorithm supported by JCE.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="securityProviderType">
        <xsd:annotation>
            <xsd:documentation>
                A security provider is a source of specific security-related functionality.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="name" type="substitutableName" use="required"/>
    </xsd:complexType>

    <xsd:complexType name="encryptionStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                An encryption strategy provides support for a specific encryption algorithm.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="name" type="substitutableName" use="required"/>
    </xsd:complexType>

    <xsd:complexType name="customSecurityProviderType">
        <xsd:complexContent>
            <xsd:extension base="securityProviderType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="provider-ref" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the security provider to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="customEncryptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="encryptionStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="strategy-ref" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            A reference to the encryption strategy (which may be a Spring bean that implements the EncryptionStrategy interface).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="passwordEncryptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="encryptionStrategyType">
                <xsd:attribute name="password" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The password to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="salt" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The salt to use (this helps prevent dictionary attacks).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="iterationCount" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The number of iterations to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="secretKeyEncryptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="encryptionStrategyType">
                <xsd:attribute name="key" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The key to use. This and the 'keyFactory-ref' attribute are mutually exclusive.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="keyFactory-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the key factory to use. This should implement the ObjectFactory interface and return a byte array. This and the 'key' attribute are mutually exclusive.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="threading-profile" type="threadingProfileType"
                 substitutionGroup="abstract-service-threading-profile">
        <xsd:annotation>
            <xsd:documentation>
                The threading profile to use for the service.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <!-- this is a general threading type used by various elements here -->
    <xsd:complexType name="threadingProfileType">
        <xsd:complexContent>
            <xsd:extension base="asynchronousThreadingProfileType">
                <xsd:attribute name="doThreading" type="substitutableBoolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            Whether threading should be used (default is true).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="asynchronousThreadingProfileType">
        <xsd:complexContent>
            <!-- this is a hack that allows us to use this general threading profile as a component threading profile
                 without retyping everything -->
            <xsd:extension base="abstractServiceThreadingProfileType">
                <xsd:attribute name="maxThreadsActive" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The maximum number of threads that will be used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maxThreadsIdle" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The maximum number of idle or inactive threads that can be in the pool before they are destroyed.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attributeGroup ref="commonThreadPoolAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--   Exception strategies                                       -->
    <!--==============================================================-->

    <xsd:element name="default-exception-strategy" type="serviceExceptionStrategyType"
                 substitutionGroup="legacy-abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Provides default exception handling.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="catch-exception-strategy" type="catchExceptionStrategyType"
                 substitutionGroup="abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Exception strategy used to handle exceptions. It will commit any transaction as if the message was consumed successfully.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="choice-exception-strategy" type="choiceExceptionStrategyType"
                 substitutionGroup="abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Exception strategy used to route to different exception strategies. It will execute the exception strategy which expression attribute matches against MuleMessage. In case there's no match, then default exception strategy will be exeucted.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="rollback-exception-strategy" type="rollbackExceptionStrategyType"
                 substitutionGroup="abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Exception strategy used to rollback inbound message. It will rollback any transaction or not consume
                inbound message unless a org.mule.api.exception.MessageRedeliveredException is thrown.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="exception-strategy" type="referenceExceptionStrategyType"
                 substitutionGroup="abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Exception strategy used to reference global exceptions within a flow or service.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="catchExceptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractNotificationExceptionStrategyType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>Destination to which a MuleMessage with an ExceptionPayload will be sent; this could be any message processor or outbound endpoint.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:group>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:complexType name="choiceExceptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="exceptionStrategyType">
                <xsd:sequence>
                    <xsd:element ref="abstract-exception-strategy" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="name" type="substitutableName" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Name of the exception strategy that will be used in ref attribute of 'exception-strategy' element
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="rollbackExceptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractNotificationExceptionStrategyType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>Destination to which the message will be sent; this could be an outbound endpoint, a router, or message processor.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:group>
                    <xsd:element name="on-redelivery-attempts-exceeded" minOccurs="0">
                        <xsd:complexType>
                            <xsd:complexContent>
                                <xsd:extension base="annotatedType">
                                    <xsd:sequence>
                                        <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="0" maxOccurs="unbounded">
                                            <xsd:annotation>
                                                <xsd:documentation>Destination to which the message will be sent in case that max redelivery attempts configured is exceeded, this
                                                    could be any sequence of outbound endpoint, router, or message processor.
                                                </xsd:documentation>
                                            </xsd:annotation>
                                        </xsd:group>
                                    </xsd:sequence>
                                </xsd:extension>
                            </xsd:complexContent>
                        </xsd:complexType>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="maxRedeliveryAttempts" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            Times a message will be redelivery until it's consider a poison message. Once maxRedeliveryAttempts is exceeded on-redelivery-attempts-exceeded child message processors will be executed.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="serviceExceptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractExceptionStrategyType">
                <xsd:attribute name="stopMessageProcessing" type="substitutableBoolean" default="false" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            Stop the flow/service when an exception occurs.  You will need to restart the flow/service manually after this (e.g, using JMX).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-exception-strategy" type="customExceptionStrategyType"
                 substitutionGroup="abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                A user-defined exception strategy.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customExceptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractExceptionStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            A class that implements the ExceptionListener interface. In addition, if an 'outbound-endpoint' element is specified, it is set as an "endpoint" bean property.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- This is left in for backwards-compatibility only, remove for next major version. -->
    <xsd:element name="default-service-exception-strategy" type="serviceExceptionStrategyType"
                 substitutionGroup="legacy-abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Deprecated: Use default-exception-strategy instead.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!-- Custom connector element -->

    <xsd:element name="custom-connector" type="customConnectorType" substitutionGroup="abstract-connector">
        <xsd:annotation>
            <xsd:documentation>
                A user-defined connector.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customConnectorType">
        <xsd:complexContent>
            <xsd:extension base="connectorType">
                <!-- This is already on the standard connector (but probably shouldn't be...)
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                 -->
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            A class that implements the Connector interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--  Object stores                                                     -->
    <!--==============================================================-->
    <xsd:element name="abstract-object-store" abstract="true" type="abstractObjectStoreType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for an object store that can be used by routers to maintain state.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="abstractObjectStoreType"/>

    <xsd:element name="in-memory-store" type="abstractMonitoredObjectStoreType"
                 substitutionGroup="abstract-object-store">
        <xsd:annotation>
            <xsd:documentation>
                An optionally bounded in-memory store for message IDs with periodic expiry of old entries. The bounded size is a soft limit and is only enforced periodically by the expiry process. This means that the store may temporarily exceed its maximum size between expiry runs but will eventually shrink to its configured size.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="simple-text-file-store" type="textFileObjectStoreType" substitutionGroup="abstract-object-store">
        <xsd:annotation>
            <xsd:documentation>
                A simple object store that stores String objects by key to a text file. This store is only suitable for storing simple key value pair strings. This store is backed by an in-memory store and supports the ability to expire and apply TTL to objects in the store.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="textFileObjectStoreType">
        <xsd:complexContent>
            <xsd:extension base="abstractMonitoredObjectStoreType">
                <xsd:attribute name="directory" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The file location (directory) where the object store will be saved. If this value is not set, Mule defaults to using 'mule.working.dir/objectstore'.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="managed-store" type="managedObjectStoreType"
		substitutionGroup="abstract-object-store">
		<xsd:annotation>
			<xsd:documentation>
				Managed Object Store
            </xsd:documentation>
		</xsd:annotation>
	</xsd:element>

	<xsd:complexType name="managedObjectStoreType">
		<xsd:complexContent>
			<xsd:extension base="abstractObjectStoreType">
				<xsd:attribute name="storeName" type="xsd:string" use="required">
					<xsd:annotation>
						<xsd:documentation>
							The ID used to retrieve the ObjectStore from the ObjectStoreManager
    					</xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
				<xsd:attribute name="persistent" type="xsd:boolean">
					<xsd:annotation>
						<xsd:documentation>
							Defines if this store should be persistent or not
    					</xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
				<xsd:attribute name="maxEntries" type="substitutableInt">
					<xsd:annotation>
						<xsd:documentation>
							The maximum number of entries that this store keeps around. Specify
							'-1' if the store is supposed to be "unbounded".
						</xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
				<xsd:attribute name="entryTTL" type="substitutableInt">
					<xsd:annotation>
						<xsd:documentation>
							The time-to-live for each message ID, specified in milliseconds, or '-1'
							for entries that should never expire. DO NOT combine this with an
							unbounded store!
                        </xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
				<xsd:attribute name="expirationInterval" type="substitutableInt">
					<xsd:annotation>
						<xsd:documentation>
							The interval for periodic bounded size enforcement and entry
							expiration, specified in milliseconds. Arbitrary positive values
							between one second and several hours or days are possible, but
							should be chosen carefully according to the expected message rate
							to prevent OutOfMemory conditions.
                        </xsd:documentation>
					</xsd:annotation>
				</xsd:attribute>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

    <xsd:complexType name="abstractMonitoredObjectStoreType">
        <xsd:complexContent>
            <xsd:extension base="abstractObjectStoreType">
                <xsd:attribute name="name" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            An ID for this store that can be used for logging and identification purposes.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maxEntries" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The maximum number of entries that this store keeps around. Specify '-1' if the store is supposed to be "unbounded".
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="entryTTL" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The time-to-live for each message ID, specified in seconds, or '-1' for entries that should never expire. DO NOT combine this with an unbounded store!
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="expirationInterval" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The interval for periodic bounded size enforcement and entry expiration, specified in seconds. Arbitrary positive values between one second and several hours or days are possible, but should be chosen carefully according to the expected message rate to prevent OutOfMemory conditions.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-object-store" type="customObjectStoreType"
                 substitutionGroup="abstract-object-store">
        <xsd:annotation>
            <xsd:documentation>
                A custom implementation of the ObjectStore interface.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="customObjectStoreType">
        <xsd:complexContent>
            <xsd:extension base="abstractObjectStoreType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration of the ObjectStore.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the ObjectStore interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:element name="spring-object-store" type="springObjectStoreType"
                 substitutionGroup="abstract-object-store">
        <xsd:annotation>
            <xsd:documentation>
                A Spring bean that implements the ObjectStore interface.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="springObjectStoreType">
        <xsd:complexContent>
            <xsd:extension base="abstractObjectStoreType">
                <xsd:attribute name="ref" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the ObjectStore bean to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--  Routing                                                     -->
    <!--==============================================================-->

    <!--==================================-->
    <!-- Simple (1-1) Message Processors  -->
    <!--==================================-->

    <xsd:element name="abstract-intercepting-message-processor" abstract="true" type="abstractInterceptingMessageProcessorType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for intercepting router elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractInterceptingMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-global-intercepting-message-processor" abstract="true"
                 type="abstractGlobalInterceptingMessageProcessorType" substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for intercepting router elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractGlobalInterceptingMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="abstractInterceptingMessageProcessorType">
                <xsd:attribute name="name" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            Identifies the processor so that other elements can reference it. Required if the processor is defined at the global level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="baseMessageFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractGlobalInterceptingMessageProcessorType">
                <xsd:attribute name="onUnaccepted" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Events that are not accepted by the filter are sent to this (optional) named message processor.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="throwOnUnaccepted" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            Whether to throw an exception if a message is not accepted
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:element name="message-filter" type="messageFilterType"  substitutionGroup="abstract-global-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A message processor that uses a filter to determine whether to process an event.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="messageFilterType">
        <xsd:complexContent>
            <xsd:extension base="baseMessageFilterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-filter">
                        <xsd:annotation>
                            <xsd:documentation>
                                Used to filter events.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="idempotent-message-filter" type="idempotentMessageFilterType"
                 substitutionGroup="abstract-global-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Ensures that only unique messages are received by a service by checking the unique ID of the incoming message. Note that the ID used can be generated from the message using an expression defined in the 'idExpression' attribute. By default, the expression used is '#[message:id]', which means the underlying endpoint must support unique message IDs for this to work. Otherwise, a UniqueIdNotSupportedException is thrown.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="idempotentMessageFilterType">
        <xsd:complexContent>
            <xsd:extension base="baseMessageFilterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-object-store" maxOccurs="1" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="idExpression" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines one or more expressions to use when extracting the ID from the message. For example, it would be possible to combine to headers as the ID of the message to provide idempotency: '#[headers:foo,bar]'. Or, you could combine the message ID with a header: '#[message:id]-#[header:foo]'. If this property is not set, '#[message:id]' will be used by default.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="valueExpression" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines one or more expressions to use when extracting the value from the message.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="storePrefix" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines the prefix of the object store names.
                        </xsd:documentation>
                    </xsd:annotation>
				</xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-redelivery-policy" abstract="true" type="abstractRedeliveryPolicyType">
            <xsd:annotation>
                <xsd:documentation>
                    A placeholder for a redelivery policy.  Redelivery policies determine what action to take when the same message
                    is redelivered repeatedly.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:element>

    <xsd:complexType name="abstractRedeliveryPolicyType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:sequence>
                    <xsd:element name="dead-letter-queue" type="singleTarget" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Message processor to call if a message exceeds its redelivery count without being processed successfully
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="maxRedeliveryCount" type="substitutableInt" default="5">
                    <xsd:annotation>
                        <xsd:documentation>
                            The maximum number of times a message can be redelivered and processed unsuccessfully before triggering
                            process-failed-message
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="idempotent-redelivery-policy" type="idempotentRedeliveryPolicyType"
                 substitutionGroup="abstract-redelivery-policy">
        <xsd:annotation>
            <xsd:documentation>
                Defines a policy for processing the redelivery of the same message
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="singleTarget">
       <xsd:complexContent>
            <xsd:extension base="abstractRoutingMessageProcessorType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="idempotentRedeliveryPolicyType">
        <xsd:complexContent>
            <xsd:extension base="abstractRedeliveryPolicyType">
                <xsd:attribute name="useSecureHash" type="xsd:boolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            Whether to use a secure hash algorithm to identify a redelivered message
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="messageDigestAlgorithm" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The secure hashing algorithm to use. If not set, the default is SHA-256.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="idExpression" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines one or more expressions to use to determine when a message has been redelivered. For example,it would be possible to combine to headers as the unique ID of the message : '#[headers:foo,bar]'. Or, you could combine the message ID with a header: '#[message:id]-#[header:foo]'. This property may only be set if useSecureHash is false..
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="object-store-ref" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The object store where the redelivery counter for each message is going to be stored.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="idempotent-secure-hash-message-filter" substitutionGroup="abstract-global-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Ensures that only unique messages are received by a service by calculating the hash of the message itself using a message digest algorithm. This provides a value with an infinitesimally small chance of a collision. This can be used to filter message duplicates. Keep in mind that the hash is calculated over the entire byte array representing the message, so any leading or trailing spaces or extraneous bytes (like padding) can produce different hash values for the same semantic message content. Care should be taken to ensure that messages do not contain extraneous bytes. This class is useful when the message does not support unique identifiers.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="idempotentMessageFilterType">
                    <xsd:attribute name="messageDigestAlgorithm" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                The secure hashing algorithm to use. If not set, the default is SHA-256.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="wire-tap" substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                The WireTap inbound router allows you to route certain messages to a different endpoint as well as to the component.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractInterceptingMessageProcessorType">
                    <xsd:sequence>
                        <xsd:group ref="messageProcessorOrOutboundEndpoint" maxOccurs="1"/>
                        <xsd:element ref="abstract-filter" minOccurs="0"/>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="combine-collections-transformer" substitutionGroup="abstract-global-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
            Takes a payload which is a Collection of Collections and turns into a single List. For example, if the payload is a Collection
            which contains a Collection with elements A and B and another Collection with elements C and D, this will turn them into
            a single Collection with elements A, B, C and D.

            This transformer will also work on MuleMessageCollections. In this case, it will take the individual Collection
            payloads of each MuleMessage and merge them into a single Collection on a new MuleMessage.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractGlobalInterceptingMessageProcessorType"/>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>


    <xsd:complexType name="baseAggregatorType">
        <xsd:complexContent>
            <xsd:extension base="abstractInterceptingMessageProcessorType">
                <xsd:sequence>
                    <xsd:element ref="abstract-message-info-mapping" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="timeout" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines a timeout in Milliseconds to wait for events to be aggregated. By default the router will throw an exeception if the router is waiting for a correlation group and times out before all group enties are received.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="failOnTimeout" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            When false, incomplete aggregation groups will be forwarded to a component on timeout as a java.util.List. When true (default), a CorrelationTimeoutException is thrown and RoutingNotification.CORRELATION_TIMEOUT is fired. The component doesn't receive any messages in this case.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                
                <xsd:attribute name="processed-groups-object-store-ref" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The object store where the processed groups are going to be stored. It is recommended that this object store has a max capacity and an expiration interval.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="event-groups-object-store-ref" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The object store where the event groups are going to be stored.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>                
                
                <xsd:attribute name="persistentStores" type="substitutableBoolean" default="false">
                	<xsd:annotation>
                        <xsd:documentation>
                            Defines if the object stores used are persistent or not. This will only be used for the internally built object stores.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
				<xsd:attribute name="storePrefix" type="substitutableName">
					<xsd:annotation>
                        <xsd:documentation>
                            Defines the prefix of the object store names. This will only be used for the internally built object stores.
                        </xsd:documentation>
                    </xsd:annotation>
				</xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="resequencer" type="baseAggregatorType"
                 substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Holds back a group of messages and resequences them using each message's correlation sequence property.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="collection-aggregator" type="baseAggregatorType"
                 substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Configures a Collection Response Router. This will return a MuleMessageCollection message type that will contain all messages received for a each correlation group.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="message-chunk-aggregator" type="baseAggregatorType"
                 substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Combines two or more messages into a single message by matching messages with a given Correlation ID. Correlation IDs are set on messages when they are dispatched by certain outbound routers, such as the Recipient List and Message Splitter routers. These messages can be aggregated back together again using this router.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="custom-aggregator"
                 substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Configures a custom message aggregator. Mule provides an abstract implementation that has a template method that performs the message aggregation. A common use of the aggregator router is to combine the results of multiple requests such as "ask this set of vendors for the best price of X".
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="baseAggregatorType">
                    <xsd:sequence>
                        <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>
                                    Spring-style property element for custom configuration.
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:sequence>
                    <xsd:attribute name="class" type="substitutableClass" use="required">
                        <xsd:annotation>
                            <xsd:documentation>
                                Fully qualified class name of the custom correlation aggregator router to be used.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:complexType name="baseSplitterType">
        <xsd:complexContent>
            <xsd:extension base="abstractInterceptingMessageProcessorType">
                <xsd:sequence>
                    <xsd:element ref="abstract-message-info-mapping" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultCorrelationAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="splitter" substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                The simple splitter splits incoming message into parts using the configured expression passing on each part in turn to the next message processor
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="baseSplitterType">
                    <xsd:attributeGroup ref="expressionAttributes"/>
            </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="collection-splitter" substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                The collection splitter accepts a collection of objects and splits the collection invoking the next message processor with each item in the collection in sequence.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="baseSplitterType"/>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="map-splitter" substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                The map splitter accepts a map of objects and splits the collection invoking the next message processor with each item in the collection in sequence.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="baseSplitterType"/>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="message-chunk-splitter" substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                The collection splitter accepts a collection of objects and splits the collection invoking the next message processor with each item in the collection in sequence.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="baseSplitterType">
                    <xsd:attribute name="messageSize" type="substitutableInt" use="required">
                        <xsd:annotation>
                            <xsd:documentation>
                                The message chunk size (in bytes) that the current message will be split into. Note that this is mutually exclusive to the 'numberOfMessages' property.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="custom-splitter" substitutionGroup="abstract-intercepting-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Configures a custom message splitter. Mule provides an abstract implementation that has a template method that performs the message aggregation.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="baseSplitterType">
                    <xsd:sequence>
                        <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>
                                    Spring-style property element for custom configuration.
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:sequence>
                    <xsd:attribute name="class" type="substitutableClass" use="required">
                        <xsd:annotation>
                            <xsd:documentation>
                                Fully qualified class name of the custom correlation aggregator router to be used.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <!-- Conditional Message Processor Elements -->
    <xsd:complexType name="abstractMessageProcessorFilterPairType" abstract="true" />

    <xsd:complexType name="whenMessageProcessorFilterPairType">
      <xsd:complexContent>
        <xsd:extension base="abstractMessageProcessorFilterPairType">
          <xsd:sequence>
            <!-- if the first message processor is a filter, it determines
                 whether this when clause is chosen or not.  This is only allowed when
                 no expression is specified -->
            <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="1" maxOccurs="unbounded" />
          </xsd:sequence>
          <xsd:attribute name="evaluator" use="optional" type="whenExpressionEvaluators">
              <xsd:annotation>
                  <xsd:documentation>The expression evaluator to use. Expression evaluators must be registered with the ExpressionEvaluatorManager before they can be used. Using the custom evaluator allows you to define your own evaluator with the 'custom-evaluator' attribute. Note that some evaluators such as xpath, groovy, and bean are loaded from other Mule modules (XML and Scripting, respectively). These modules must be on your classpath before the evaluator can be used.
                  </xsd:documentation>
              </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="expression" type="xsd:string" use="optional">
              <xsd:annotation>
                  <xsd:documentation>The expression to evaluate. The syntax of this attribute changes depending on the evaluator being used.
                  </xsd:documentation>
              </xsd:annotation>
          </xsd:attribute>
          <xsd:attribute name="custom-evaluator" type="substitutableName" use="optional">
              <xsd:annotation>
                  <xsd:documentation>The name of the custom evaluator to use. This attribute is only used when the 'evaluator' attribute is set to "custom". You can plug in your own expression evaluators by registering them with the ExpressionEvaluatorManager.
                  </xsd:documentation>
              </xsd:annotation>
          </xsd:attribute>
        </xsd:extension>
      </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="otherwiseMessageProcessorFilterPairType">
      <xsd:complexContent>
        <xsd:extension base="abstractMessageProcessorFilterPairType">
          <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="1" maxOccurs="unbounded" />
        </xsd:extension>
      </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="foreach" type="foreachProcessorType"
                 substitutionGroup="abstract-intercepting-message-processor"/>
    <xsd:complexType name="foreachProcessorType">
        <xsd:complexContent>
            <xsd:extension base="abstractInterceptingMessageProcessorType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="collection" use="optional" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            An expression to that returns a java collection, object array, map or DOM nodes.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="batchSize" use="optional" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            Partitions the collection in subcollections of the specified size.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="rootMessageVariableName" use="optional" default="rootMessage" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Property name where the parent message is stored.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="counterVariableName" use="optional" default="counter" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Property name used to store the number of message being iterated.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!--==================================-->
    <!-- Routing (1-n) Message Processors  -->
    <!--==================================-->

    <xsd:element name="abstract-routing-message-processor" abstract="true" type="abstractRoutingMessageProcessorType" substitutionGroup="abstract-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for intercepting router elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractRoutingMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageProcessorType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="baseSingleRouteRoutingMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="abstractRoutingMessageProcessorType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="1" maxOccurs="unbounded" />
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="baseMultipleRoutesRoutingMessageProcessorType">
        <xsd:complexContent>
            <xsd:extension base="baseSingleRouteRoutingMessageProcessorType">
                <xsd:sequence>
                   <xsd:element ref="abstract-message-info-mapping" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultCorrelationAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-router" substitutionGroup="abstract-routing-message-processor">
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="baseMultipleRoutesRoutingMessageProcessorType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:complexType name="selectiveOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractRoutingMessageProcessorType">
                <xsd:sequence>
                    <xsd:element name="when" type="whenMessageProcessorFilterPairType" minOccurs="1" maxOccurs="unbounded"/>
                    <xsd:element name="otherwise" type="otherwiseMessageProcessorFilterPairType" minOccurs="0" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="choice" type="selectiveOutboundRouterType"
                 substitutionGroup="abstract-routing-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Sends the message to the first endpoint whose condition has been satisfied. If no conditions were satisfied, sends to the configured default endpoint if configured, or throws an exception if not configured.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!-- Deprecated -->
    <xsd:element name="all" type="baseMultipleRoutesRoutingMessageProcessorType" substitutionGroup="abstract-routing-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message to multiple message processors or outbound endpoints.
                @Deprecated since 3.5.0. Use scatter-gather instead
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="processorWithAtLeastOneTargetType" >
        <xsd:complexContent>
            <xsd:extension base="abstractRoutingMessageProcessorType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="processorWithExactlyOneTargetType" >
        <xsd:complexContent>
            <xsd:extension base="abstractRoutingMessageProcessorType">
                <xsd:sequence>
                    <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="first-successful" substitutionGroup="abstract-routing-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Sends a message to a list of message processors until one processes it
                successfully
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="processorWithAtLeastOneTargetType">
                    <xsd:attribute name="failureExpression" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies an expression that when evaluated as determines if the processing of one a route was a failure or not.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:element name="until-successful" substitutionGroup="abstract-routing-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Attempts to route a message to the message processor it contains in an asynchronous manner.
                Routing is considered successful if no exception has been raised and, optionally, if the response matches an expression
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractRoutingMessageProcessorType">
                    <xsd:sequence>
                        <xsd:element name="threading-profile" type="asynchronousThreadingProfileType" minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>
                                    Threading profile used to process the message processors inside the until-successful.
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="1" maxOccurs="1"/>
                    </xsd:sequence>
                    <xsd:attribute name="objectStore-ref" type="xsd:string" use="optional">
                        <xsd:annotation>
                            <xsd:documentation>
                                Reference to the org.mule.api.store.ListableObjectStore that will be used to store events pending (re)processing.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="maxRetries" type="substitutableInt" use="optional" default="5">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies the maximum number of processing retries that will be performed.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="millisBetweenRetries" type="substitutableInt" use="optional">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies the minimum time interval between two process retries in milliseconds.
                                The actual time interval depends on the previous execution but should not exceed twice this number.
                                Default value is 60000 (one minute)
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="secondsBetweenRetries" type="substitutableInt" use="optional">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies the minimum time interval between two process retries in seconds.
                                The actual time interval depends on the previous execution but should not exceed twice this number.
                                THIS ATTRIBUTE IS DEPRECATED. Please use millisBetweenRetries instead
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="failureExpression" type="xsd:string" use="optional">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies an expression that when evaluated determines if the processing of one a route was a failure or not.
                                If no expression is specified, only exceptions will be considered as processing failures.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="ackExpression" type="xsd:string" use="optional">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies an expression that when evaluated determines the synchronous response of until-successful.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="deadLetterQueue-ref" type="xsd:string" use="optional">
                        <xsd:annotation>
                            <xsd:documentation>
                                The endpoint or message processor to which undeliverable messages are sent after all retries have been attempted.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="synchronous" type="substitutableBoolean" use="optional" default="false">
                        <xsd:annotation>
                            <xsd:documentation>
                                Defines if the route inside until-successful should be executed asynchronously or synchronously within the caller thread.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:element name="scatter-gather" substitutionGroup="abstract-routing-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message to multiple message processors or outbound endpoints in parallel.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractRoutingMessageProcessorType">
                    <xsd:sequence>
                        <xsd:element name="custom-aggregation-strategy" type="aggregationStrategyType" minOccurs="0" maxOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation>
                                    Allows customizing the logic used for aggregation the events back together.
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="threading-profile" type="threadingProfileType" minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>
                                    Threading profile used to process the message processors inside the until-successful.
                                </xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:group ref="messageProcessorOrOutboundEndpoint" minOccurs="2" maxOccurs="unbounded"/>
                    </xsd:sequence>
                    <xsd:attribute name="timeout" type="substitutableLong" use="optional" default="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Sets a timeout in milliseconds for each route. Values lower or equals than zero means no timeout. 
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    
    <xsd:complexType name="aggregationStrategyType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="class" type="substitutableClass" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The canonical name of a class that implements org.mule.routing.AggregationStrategy.
                            Such a class is required to have a default constructor.
                            This property cannot be set at the same time as 'ref'
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="ref" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            A reference to a registered bean that implements org.mule.routing.AggregationStrategy.
                            This property cannot be set at the same time as 'class'
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
	
    <xsd:element name="round-robin" substitutionGroup="abstract-routing-message-processor"
                 type="processorWithAtLeastOneTargetType">
        <xsd:annotation>
            <xsd:documentation>
                Send each message received to the next message processor in the circular list of targets
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="recipient-list" substitutionGroup="abstract-routing-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message to multiple endpoints, over the same endpoint, or implements routing-slip behavior where the next destination for the message is determined from message properties or the payload. The recipients can be extracted from the message using an expression, or you can specify a static list of recipient endpoints. (As of version 2.1)
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractRoutingMessageProcessorType">
                    <xsd:sequence>
                       <xsd:element ref="abstract-message-info-mapping" minOccurs="0"/>
                    </xsd:sequence>
                    <xsd:attributeGroup ref="defaultCorrelationAttributes"/>
                    <xsd:attributeGroup ref="expressionAttributes"/>
                    <!--  See MULE-5069 <xsd:attributeGroup ref="allExchangePatterns" />-->
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="dynamic-round-robin" substitutionGroup="abstract-routing-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Sends each message received to the next message processor in the circular list of targets. The list of message processors is obtained dynamically using the configured route resolver
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractDynamicRoutingMessageProcessor"/>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="dynamic-all" substitutionGroup="abstract-routing-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message to multiple message processors or outbound endpoints. THe list of message processors is obtained dynamically using the configured route resolver
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractDynamicRoutingMessageProcessor">
                    <xsd:sequence>
                        <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="dynamic-first-successful" substitutionGroup="abstract-routing-message-processor">
        <xsd:annotation>
            <xsd:documentation>
                Sends a message to a list of message processors until one processes it successfully. The list of message processors is obtained dynamically using the configured route resolver
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractDynamicRoutingMessageProcessor">
                    <xsd:attribute name="failureExpression" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                Specifies an expression that when evaluated as determines if the processing of one a route was a failure or not.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:complexType name="abstractDynamicRoutingMessageProcessor">
        <xsd:complexContent>
            <xsd:extension base="abstractRoutingMessageProcessorType">
                <xsd:sequence minOccurs="1" maxOccurs="1">
                    <xsd:element ref="abstract-dynamic-route-resolver"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-dynamic-route-resolver" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for route resolver elements, which return a set of routes.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="custom-route-resolver" type="customRouterResolverType"
                 substitutionGroup="abstract-dynamic-route-resolver">
        <xsd:annotation>
            <xsd:documentation>
                A mechanism to lookup routes from the service registry specifying service name and service version.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customRouterResolverType">
        <xsd:complexContent>
            <xsd:extension base="annotatedType">
                <xsd:attribute name="ref" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            A reference to a bean definition of a DynamicRouteResolver.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <!--=======================-->
    <!--  2.x Inbound Routers  -->
    <!--=======================-->

    <xsd:complexType name="filteredInboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-filter" minOccurs="0"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="idempotent-receiver-router" type="idempotentReceiverType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Ensures that only unique messages are received by a service by checking the unique ID of the incoming message. Note that the ID used can be generated from the message using an expression defined in the 'idExpression' attribute. By default, the expression used is '#[message:id]', which means the underlying endpoint must support unique message IDs for this to work. Otherwise, a UniqueIdNotSupportedException is thrown.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="idempotent-secure-hash-receiver-router" type="idempotentSecureHashReceiverType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Ensures that only unique messages are received by a service by calculating the hash of the message itself using a message digest algorithm. This provides a value with an infinitesimally small chance of a collision. This can be used to filter message duplicates. Keep in mind that the hash is calculated over the entire byte array representing the message, so any leading or trailing spaces or extraneous bytes (like padding) can produce different hash values for the same semantic message content. Care should be taken to ensure that messages do not contain extraneous bytes. This class is useful when the message does not support unique identifiers.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="idempotentReceiverType">
        <xsd:complexContent>
            <xsd:extension base="abstractInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-object-store" maxOccurs="1" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="idExpression" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines one or more expressions to use when extracting the ID from the message. For example, it would be possible to combine to headers as the ID of the message to provide idempotency: '#[headers:foo,bar]'. Or, you could combine the message ID with a header: '#[message:id]-#[header:foo]'. If this property is not set, '#[message:id]' will be used by default.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="idempotentSecureHashReceiverType">
        <xsd:complexContent>
            <xsd:extension base="abstractInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-object-store" maxOccurs="1" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="messageDigestAlgorithm" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The secure hashing algorithm to use. If not set, the default is SHA-256.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="wire-tap-router" type="wireTapRouterType" substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                The WireTap inbound router allows you to route certain messages to a different endpoint as well as to the component.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="wireTapRouterType">
        <xsd:complexContent>
            <xsd:extension base="filteredInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="forwarding-router" type="abstractInboundRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Allows messages to be forwarded to the outbound routers without first being processed by a component.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="selective-consumer-router" type="filteredInboundRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Applies one or more filters to the incoming message. If the filters match, the message is forwarded to the component. Otherwise, the message is forwarded to the catch-all strategy on the router. If no catch-all strategy is configured, the message is ignored and a warning is logged.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="correlation-resequencer-router" type="baseAggregatorRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Holds back a group of messages and resequences them using each message's correlation sequence property.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="message-chunking-aggregator-router" type="messageChunkingAggregatorRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Combines two or more messages into a single message by matching messages with a given Correlation ID. Correlation IDs are set on messages when they are dispatched by certain outbound routers, such as the Recipient List and Message Splitter routers. These messages can be aggregated back together again using this router.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="messageChunkingAggregatorRouterType">
        <xsd:complexContent>
            <xsd:extension base="baseAggregatorRouterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-correlation-aggregator-router" type="customCorrelationAggregatorRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Configures a custom message aggregator. Mule provides an abstract implementation that has a template method that performs the message aggregation. A common use of the aggregator router is to combine the results of multiple requests such as "ask this set of vendors for the best price of X".
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customCorrelationAggregatorRouterType">
        <xsd:complexContent>
            <xsd:extension base="messageChunkingAggregatorRouterType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            Fully qualified class name of the custom correlation aggregator router to be used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="collection-aggregator-router" type="baseAggregatorRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Configures a Collection Response Router. This will return a MuleMessageCollection message type that will contain all messages received for a each correlation group.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="custom-inbound-router" type="customInboundRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Allows for custom inbound routers to be configured.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="customInboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property elements so that custom configuration can be configured on the custom router.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of InboundRouter (fully qualified Java class name)
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="baseAggregatorRouterType">
        <xsd:complexContent>
            <xsd:extension base="filteredInboundRouterType">
                <xsd:attribute name="timeout" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines a timeout in Milliseconds to wait for events to be aggregated. By default the router will throw an exeception if the router is waiting for a correlation group and times out before all group enties are received.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="failOnTimeout" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            When false, incomplete aggregation groups will be forwarded to a component on timeout as a java.util.List. When true (default), a CorrelationTimeoutException is thrown and RoutingNotification.CORRELATION_TIMEOUT is fired. The component doesn't receive any messages in this case.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ResponseRouters -->
    <!--  Deprecated -->
    <xsd:element name="single-async-reply-router" type="asyncReplyRouterType"
                 substitutionGroup="abstract-async-reply-router">
        <xsd:annotation>
            <xsd:documentation>
                Configures a Single Response Router. This will return the first message it receives on a reply endpoint and will discard the rest.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!--  Deprecated -->
    <xsd:element name="collection-async-reply-router" type="asyncReplyRouterType"
                 substitutionGroup="abstract-async-reply-router">
        <xsd:annotation>
            <xsd:documentation>
                Configures a Collection Response Router. This will return a MuleMessageCollection message type that will contain all messages received for the current correlation.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!--  Deprecated -->
    <xsd:complexType name="asyncReplyRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractAsyncReplyRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-inbound-endpoint" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                The endpoint used to receive the response(s) on.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--  Deprecated -->
    <xsd:element name="custom-async-reply-router" type="customAsyncReplyRouterType"
                 substitutionGroup="abstract-async-reply-router"/>
    <xsd:complexType name="customAsyncReplyRouterType">
        <xsd:complexContent>
            <xsd:extension base="asyncReplyRouterType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property elements so that custom configuration can be configured on the custom router.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            A fully qualified Java class name of the router to use. The router should either extend {{org.mule.routing.response.AbstractResponseRouter}} or {{org.mule.routing.response.AbstractResponseAggregator}}.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- Outbound Router implementations -->

    <!-- Outbound router element and attribute groups -->

    <xsd:group name="defaultOutboundRouterElements">
        <xsd:sequence>
            <xsd:element name="reply-to" type="endpointRefType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Defines where the message should be routed after the recipient of the message to which this service dispatches has finished with it.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="abstract-transaction" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Defines an overall transaction that will be used for all endpoints on this router.  This is only useful when you want to define an outbound only transaction that will commit all of the transactions defined on the outbound endpoints for this router.  Note that you must still define a transaction on each of the endpoints that should take part in the transaction.  These transactions should always be configured to JOIN the existing transaction.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:group>

    <xsd:group name="defaultFilteredOutboundRouterElements">
        <xsd:sequence>
            <xsd:group ref="defaultOutboundRouterElements" />
            <xsd:element ref="abstract-filter" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Filters the messages to be processed by this router.
                        @Deprecated since 2.2.  Configure the filter on the endpoint instead of the router.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="abstract-transformer" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Filters are applied before message transformations. A transformer can be configured here to transform messages before they are filtered.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:group>

    <xsd:attributeGroup name="defaultCorrelationAttributes">
        <xsd:attribute name="enableCorrelation" default="IF_NOT_SET">
            <xsd:annotation>
                <xsd:documentation>
                    Specifies whether Mule should give outgoing messages a correlation ID. The default behavior is to give messages a correlation ID only if they don't already have one, so that existing correlation IDs are maintained.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN">
                    <xsd:enumeration value="ALWAYS" />
                    <xsd:enumeration value="NEVER" />
                    <xsd:enumeration value="IF_NOT_SET" />
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="defaultOutboundRouterAttributes">
        <xsd:attributeGroup ref="defaultCorrelationAttributes"/>
        <xsd:attribute name="transformer-refs" type="xsd:NMTOKENS">
            <xsd:annotation>
                <xsd:documentation>
                    A list of the transformers that will be applied to the message in order before it is delivered to the component.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="defaultFilteredOutboundRouterAttributes">
        <xsd:attributeGroup ref="defaultOutboundRouterAttributes"/>
        <xsd:attribute name="useTemplates" type="substitutableBoolean" default="true">
            <xsd:annotation>
                <xsd:documentation>
                    Determines if placeholders with expressions can be used with the form [ ] in endpoint uri's.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <!-- Default Outbound Router Types -->
    <xsd:complexType name="outboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint"/>
                    <xsd:group ref="defaultOutboundRouterElements"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultCorrelationAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="filteringOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint"/>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

     <xsd:complexType name="multipleEndpointFilteringOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" maxOccurs="unbounded"/>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="singleEndpointFilteringOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" maxOccurs="1"/>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--  Concrete Outbound Routers -->

    <xsd:element name="pass-through-router" type="outboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                This router always matches and simply sends or dispatches message via the endpoint that is configured.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!--  FilteringOutboundRouter only uses a single endpoint. For now this needs to support multiple endpoints for MessageBuilderComponent usage only. -->
    <xsd:element name="filtering-router" type="singleEndpointFilteringOutboundRouterType" substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Uses filters to determine whether the message matches a particular criteria and if so will route the message to the endpoint configured on the router.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="chaining-router" type="multipleEndpointFilteringOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends the message through multiple endpoints using the result of the first invocation as the input for the next.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="exception-based-router" type="multipleEndpointFilteringOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends a message over an endpoint by selecting the first endpoint that can connect to the transport.  Endpoints are listed statically in the router configuration.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="recipient-list-exception-based-router" type="expressionRecipientListRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends a message over an endpoint by selecting the first endpoint that can connect to the transport.  Endpoints/recipients are extracted from the message using an expression.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="multicasting-router" type="multipleEndpointFilteringOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message over multiple endpoints.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="sequence-router" type="multipleEndpointFilteringOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message sequentially over multiple endpoints. Stops the routing process if receives a null or an exception message as a partial response from a synchronous endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="endpoint-selector-router" type="endpointSelectorRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Selects the outgoing endpoint based on an expression evaluator ("header:endpoint" by default). It will first try to match the endpoint by name and then by address. The endpoints to use can be set on the router itself or be global endpoint definitions.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="endpointSelectorRouterType">
        <xsd:complexContent>
            <xsd:extension base="multipleEndpointFilteringOutboundRouterType">
                <xsd:attributeGroup ref="expressionAttributes"/>
                <xsd:attribute name="default" type="xsd:string" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the default endpoint to use if the expression returns null. This can be used as an 'else' condition to route messages that don't contain the expected routing information.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Splitter routers -->

    <!-- Extends AbstractMessageSplitter-->
    <xsd:complexType name="messageSplitterOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="multipleEndpointFilteringOutboundRouterType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Extends AbstractRoundRobinMessageSplitter -->
    <xsd:complexType name="roundRobinSplitterType">
        <xsd:complexContent>
            <xsd:extension base="messageSplitterOutboundRouterType">
                <xsd:attribute name="deterministic" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            If 'disableRoundRobin' is false and this option is true (the default) then the first message part will be routed to the first endpoint, the second part to the second endpoint, etc, with the nth part going to the (n modulo number of endpoints) endpoint. If false then the messages will be distributed equally amongst all endpoints.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="disableRoundRobin" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            If filters are being used on endpoints then round robin behaviour is probably not desirable. This flag switches round robin behaviour off, it is on by default.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="failIfNoMatch" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            If 'disableRoundRobin' is true, there may be situations where the current split message does not match any endpoints.  this flag controls whether an exception should be thrown when a match is not found.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="list-message-splitter-router" type="roundRobinSplitterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                The Filtering List Message Splitter accepts a list of objects that is split each object being routed to different endpoints.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="expression-splitter-router" type="expressionSplitterOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Splits the message based on an expression. The expression must return one or more message parts in order to be effective.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>


    <xsd:complexType name="expressionSplitterOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="roundRobinSplitterType">
                <xsd:attributeGroup ref="expressionAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Messgae chunking routers -->
    <xsd:element name="message-chunking-router" type="chunkingRouterType" substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Allows you to split a single message into a number of fixed-length messages that will all be routed to the same endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="chunkingRouterType">
        <xsd:complexContent>
            <xsd:extension base="multipleEndpointFilteringOutboundRouterType">
                <xsd:attribute name="messageSize" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The message chunk size (in bytes) that the current message will be split into. Note that this is mutually exclusive to the 'numberOfMessages' property.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="numberOfMessages" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The number of message peices to break the current message into.  This property is less useful than the 'message' size property since, usually messages are constricted by size. Note that this is mutually exclusive to the 'messageSize' property.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- recipient List routers -->
    <xsd:element name="static-recipient-list-router" type="staticRecipientListRouterType" substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message to multiple endpoints over the same endpoint, or implements routing-slip behavior where the next destination for the message is determined from message properties or the payload. It uses a static list of recipient endpoints.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="staticRecipientListRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                    <xsd:element name="recipients" type="listOrSetType" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                Static list of recipients that the outgoing message is sent to. The default delimiter is ','.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
                <xsd:attribute name="recipientsProperty" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines a property name on the current message where a list of endpoint names (or URIs) can be obtained. This property can return a {{java.util.List}} of values or a delimited {{java.lang.String}}. If the 'recipientsProperty' returns a string then the 'recipientsDelimiter' property is used to split the string.
                            If the entries in the String or List define endpoint names, these will be looked up at runtime. If the entries define endpoint URIs these endpoints will be created at runtime.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="recipientsDelimiter" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The delimiter to use when splitting a String list of recipients.  the default is ','. This property is only used with the 'recipientsProperty'.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="synchronous" type="xsd:boolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            This flag controls whether the message will be sent to the recipients synchronously. Unlike other routers th recipient list router doesn't have pre-configured endpoints so the synchronicity of the endpoint cannot be honoured.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="expression-recipient-list-router" type="expressionOrStaticRecipientListRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message to multiple endpoints over the same endpoint, or implements routing-slip behavior where the next destination for the message is determined from message properties or the payload. The recipients can be extracted from the message using an expression, or you can specify a static list of recipient endpoints. (As of version 2.1)
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="expressionRecipientListRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
                <xsd:attributeGroup ref="expressionAttributes"/>
                <xsd:attribute name="synchronous" type="xsd:boolean">
                    <xsd:annotation>
                        <xsd:documentation>This flag controls whether the message will be sent to the recipients synchronously. Unlike other routers th recipient list router doesn't have pre-configured endpoints so the synchronicity of the endpoint cannot be honoured.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="expressionOrStaticRecipientListRouterType">
        <xsd:complexContent>
            <xsd:extension base="expressionRecipientListRouterType">
                <xsd:sequence>
                    <xsd:element name="recipients" type="listOrSetType" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                A static list of endpoint names or URIs that will be used as recipients of the current message. If the expression on this router returns a list of endpoint names, the endpoints here will be checked as well as any global endpoints.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- custom router -->
    <xsd:element name="custom-outbound-router" type="customOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Allows you to configure a custom outbound router by specifying the custom router class and by using Spring properties.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property elements so that custom configuration can be configured on the
                                custom router.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultOutboundRouterAttributes"/>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of OutboundRouter (fully qualified Java class name)
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- Catch all strategy implementations -->
    <xsd:element name="logging-catch-all-strategy" type="loggingCatchAllStrategyType" substitutionGroup="abstract-catch-all-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Does nothing with the message but simply logs (using the WARN log level) the fact that the message was not dispatched because no routing path was defined.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="loggingCatchAllStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractCatchAllStrategyType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-catch-all-strategy" type="customCatchAllStrategyType"
                 substitutionGroup="abstract-catch-all-strategy"/>
    <xsd:complexType name="customCatchAllStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractCatchAllStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            Fully qualified class name of the custom catch-all strategy to be used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="forwarding-catch-all-strategy" type="forwardingCatchAllStrategyType"
                 substitutionGroup="abstract-catch-all-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Forwards the message to the specified endpoint if no outbound routers match.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="forwardingCatchAllStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractCatchAllStrategyType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-forwarding-catch-all-strategy" type="customForwardingCatchAllStrategyType"
                 substitutionGroup="abstract-catch-all-strategy"/>
    <xsd:complexType name="customForwardingCatchAllStrategyType">
        <xsd:complexContent>
            <xsd:extension base="forwardingCatchAllStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            Fully qualified class name of the custom forwarding catch-all strategy to be used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Message Info Mappers -->

    <xsd:element name="abstract-message-info-mapping" abstract="true" type="abstractMessageInfoMappingType">
        <xsd:annotation>
            <xsd:documentation>Maps the attributes of the current message to known message elements in Mule, namely Message ID and CorrrelationID.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractMessageInfoMappingType"/>

    <xsd:element name="expression-message-info-mapping" type="expressionMessageInfoMappingType"
                 substitutionGroup="abstract-message-info-mapping">
        <xsd:annotation>
            <xsd:documentation>
                Allows expressions to be configured to extract the message information.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="expressionMessageInfoMappingType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageInfoMappingType">
                <xsd:attribute name="messageIdExpression" type="xsd:string" use="required"/>
                <xsd:attribute name="correlationIdExpression" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-message-info-mapping" type="customMessageInfoMappingType"
                 substitutionGroup="abstract-message-info-mapping">
        <xsd:annotation>
            <xsd:documentation>
                Allows configuraton of a custom implementation of MessageInfoMapping.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customMessageInfoMappingType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageInfoMappingType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the MessageInfoMapping interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--  Lifecycle Adapters                                            -->
    <!--==============================================================-->

    <xsd:element name="abstract-lifecycle-adapter-factory" abstract="true" type="abstractLifecycleAdapterFactory"/>
    <xsd:complexType name="abstractLifecycleAdapterFactory">
        <xsd:annotation>
            <xsd:documentation>
                Allows a lifecycle adaptor factory to be implemented, which allows an alternative custom lifecycle adaptor to be used if required instead of the default implementation that propagates the Mule lifecycle to component implementations.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:complexType>
    <xsd:complexType name="customLifecycleAdapterFactory">
        <xsd:complexContent>
            <xsd:extension base="abstractLifecycleAdapterFactory">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Spring-style property element for custom configuration.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the LifecycleAdapter interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="custom-lifecycle-adapter-factory" type="customLifecycleAdapterFactory"
                 substitutionGroup="abstract-lifecycle-adapter-factory">
        <xsd:annotation>
            <xsd:documentation>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!--==============================================================-->
    <!--  Object Factories                                            -->
    <!--==============================================================-->

    <xsd:element name="abstract-object-factory" abstract="true" type="abstractObjectFactoryType"/>
    <xsd:complexType name="abstractObjectFactoryType">
        <xsd:annotation>
            <xsd:documentation>
                An object factory is used to obtain object instances. The object factory is responsible for object creation and can implement different patterns, such a singleton or prototype, or lookup an instance from other object containers.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:group ref="propertiesGroup">
                <xsd:annotation>
                    <xsd:documentation>
                        Properties to be set on the created object.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:group>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="genericObjectFactoryType">
        <xsd:sequence>
            <xsd:element ref="abstract-object-factory"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:element name="spring-object" type="springBeanLookupType" substitutionGroup="abstract-object-factory"/>
    <xsd:complexType name="springBeanLookupType">
        <xsd:annotation>
            <xsd:documentation>
                Object factory used to obtain Spring bean instances. This object factory does not create any instances but rather looks them up from Spring.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractObjectFactoryType">
                <xsd:attribute name="bean" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>Name of Spring bean to look up.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="singleton-object" type="singletonObjectFactoryType" substitutionGroup="abstract-object-factory"/>
    <xsd:complexType name="singletonObjectFactoryType">
        <xsd:annotation>
            <xsd:documentation>
                Object factory that creates and always returns a singleton object instance.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractObjectFactoryType">
                <xsd:attribute name="class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>Class name</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="prototype-object" type="prototypeObjectFactoryType" substitutionGroup="abstract-object-factory"/>
    <xsd:complexType name="prototypeObjectFactoryType">
        <xsd:annotation>
            <xsd:documentation>
                Object factory that creates and returns a new 'prototype' object instance every time it is called.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractObjectFactoryType">
                <xsd:attribute name="class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>Class name</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-pooling-profile" abstract="true" type="abstractPoolingProfileType"/>
    <xsd:complexType name="abstractPoolingProfileType"/>

    <xsd:element name="pooling-profile" type="poolingProfileType" substitutionGroup="abstract-pooling-profile"/>
    <xsd:complexType name="poolingProfileType">
        <xsd:annotation>
            <xsd:documentation>
                A pooling profile is used to configure the pooling behaviour of Mule components. Each component can have its own pooling profile.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractPoolingProfileType">
                <xsd:attribute name="maxActive" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>Controls the maximum number of Mule components that can be borrowed from a session at one time. When set to a negative value, there is no limit to the number of components that may be active at one time. When maxActive is exceeded, the pool is said to be exhausted.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maxIdle" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>Controls the maximum number of Mule components that can sit idle in the pool at any time. When set to a negative value, there is no limit to the number of Mule components that may be idle at one time.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="initialisationPolicy" default="INITIALISE_ONE">
                    <xsd:annotation>
                        <xsd:documentation>Determines how components in a pool should be initialized. The possible values are: INITIALISE_NONE (will not load any components into the pool on startup), INITIALISE_ONE (will load one initial component into the pool on startup), or INITIALISE_ALL (will load all components in the pool on startup)</xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="INITIALISE_NONE"/>
                            <xsd:enumeration value="INITIALISE_ONE"/>
                            <xsd:enumeration value="INITIALISE_ALL"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
                <xsd:attribute name="exhaustedAction" default="WHEN_EXHAUSTED_GROW">
                    <xsd:annotation>
                        <xsd:documentation>Specifies the behavior of the Mule component pool when the pool is exhausted. Possible values are: "WHEN_EXHAUSTED_FAIL", which will throw a NoSuchElementException, "WHEN_EXHAUSTED_WAIT", which will block by invoking Object.wait(long) until a new or idle object is available, or WHEN_EXHAUSTED_GROW, which will create a new Mule instance and return it, essentially making maxActive meaningless. If a positive maxWait value is supplied, it will block for at most that many milliseconds, after which a NoSuchElementException will be thrown. If maxThreadWait is a negative value, it will block indefinitely.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="WHEN_EXHAUSTED_GROW"/>
                            <xsd:enumeration value="WHEN_EXHAUSTED_WAIT"/>
                            <xsd:enumeration value="WHEN_EXHAUSTED_FAIL"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
                <xsd:attribute name="maxWait" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>Specifies the number of milliseconds to wait for a pooled component to become available when the pool is exhausted and the exhaustedAction is set to WHEN_EXHAUSTED_WAIT.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="evictionCheckIntervalMillis" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>Specifies the number of milliseconds between runs of the object evictor. When non-positive, no object evictor is executed..</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="minEvictionMillis" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>Determines the minimum amount of time an object may sit idle in the pool before it is eligible for eviction. When non-positive, no objects will be evicted from the pool due to idle time alone.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!--==============================================================-->
    <!--  Utils / Standard Types                                      -->
    <!--==============================================================-->


    <!-- corresponds to TlsIndirectKeyStore, named as tls-client in transport namespace -->
    <xsd:complexType name="tlsClientKeyStoreType">
        <xsd:annotation>
            <xsd:documentation>
                Configure client key stores. TLS/SSL connections are made on behalf of an entity, which can be anonymous or identified by a certificate. This interface specifies how a keystore can be used to provide the certificates (and associated private keys) necessary for identification. This is also used as the trust store if no other trust store is specified and the explicitTrustStoreOnly parameter in the server trust store configuration is false. WARNING - due to restrictions in library implementations the values specified here typically apply to all connectors using this transport.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="path" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The location (which will be resolved relative to the current classpath and file system, if possible) of the keystore that contains public certificates and private keys for identification.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="storePassword" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The password used to protect the keystore.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="class"  type="keystoreType">
            <xsd:annotation>
                <xsd:documentation>
                    Deprecated.  use "type" instead
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="type"  type="keystoreType">
            <xsd:annotation>
                <xsd:documentation>
                    The type of keystore used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- corresponds to TlsDirectKeyStore, named as tls-key-store in transport namespace -->
    <xsd:complexType name="tlsKeyStoreType">
        <xsd:annotation>
            <xsd:documentation>
                Configures key stores. TLS/SSL connections are made on behalf of an entity, which can be anonymous or identified by a certificate. This interface specifies how a keystore can be used to provide the certificates (and associated private keys) necessary for identification.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="path" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The location (which will be resolved relative to the current classpath and file system, if possible) of the keystore that contains public certificates and private keys for identification.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="class" type="keystoreType">
            <xsd:annotation>
                <xsd:documentation>
                    Deprecated.  use "type" instead
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="type" type="keystoreType">
            <xsd:annotation>
                <xsd:documentation>
                    The type of keystore used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="keyAlias" type="xsd:string" use="optional">
            <xsd:annotation>
                <xsd:documentation>
                    The alias of the key to use.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="keyPassword" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The password used to protect the private key.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="storePassword" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The password used to protect the keystore.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="algorithm" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The algorithm used by the key store.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- corresponds to TlsIndirectTrustStore, named as tls-trust-store in transport namespace -->
    <xsd:complexType name="tlsTrustStoreType">
        <xsd:annotation>
            <xsd:documentation>
                Configures a trust store. TLS/SSL connections are made to trusted systems. The public certificates of trusted systems are stored in a keystore (called a trust store) and used to verify that the connection made to a remote system is the expected identity.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="path" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The location (which will be resolved relative to the current classpath and file system, if possible) of the keystore that contains public certificates of trusted servers.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="storePassword" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The password used to protect the trust store.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- corresponds to TlsDirectTrustStore, named as tls-server in transport namespace
         note that this extends tlsTrustStoreType, so only one of the two is needed -->
    <xsd:complexType name="tlsServerTrustStoreType">
        <xsd:annotation>
            <xsd:documentation>
                Configures a direct trust store. TLS/SSL connections are made to trusted systems. The public certificates of trusted systems are stored in a keystore (called a trust store) and used to verify that the connection made to a remote system is the expected identity.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="tlsTrustStoreType">
                <xsd:attribute name="class"  type="keystoreType">
                    <xsd:annotation>
                        <xsd:documentation>
                            Deprecated.  use "type" instead
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="type"  type="keystoreType">
                    <xsd:annotation>
                        <xsd:documentation>
                            The type of keystore used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="algorithm" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The algorithm used by the trust store.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <!-- should be of type TrustManagerFactory -->
                <xsd:attribute name="factory-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Reference to a TrustManagerFactory configured as a Spring bean.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="explicitOnly" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            Specifies whether the key store data should not be used when a trust store is otherwise undefined.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="requireClientAuthentication" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            If a server socket is constructed directly, this attribute is used to determine whether client authentication is required. This does not apply to client connections.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="keystoreType">
        <xsd:annotation>
            <xsd:documentation>
                A type that defines a Java keystore..
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                    <xsd:enumeration value="jks">
                        <xsd:annotation>
                            <xsd:documentation>
                                The default Java KeyStore.  If no keystore type is specified, "jks" will be used.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="jceks">
                        <xsd:annotation>
                            <xsd:documentation>
                                Used by the Java Cryptography Extension
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:enumeration>
                    <xsd:enumeration value="pkcs12"><xsd:annotation>
                        <xsd:documentation>
                            A format commonly used to store private keys.
                        </xsd:documentation>
                    </xsd:annotation>
                    </xsd:enumeration>
                </xsd:restriction>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Any other keystore type.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <!-- corresponds to TlsProtocolHandler, named as tls-protocol-handler.
         DEPRECATED since 3.5 - This property will be ignored -->
    <xsd:complexType name="tlsProtocolHandler">
        <xsd:annotation>
            <xsd:documentation>
                Configures the global Java protocol handler. DEPRECATED since 3.5 - This is no longer necessary and will be ignored
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="property" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    Sets the java.protocol.handler.pkgs system property. DEPRECATED since 3.5 - This is no longer necessary and will be ignored
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:simpleType name="propertyPlaceholderType">
        <xsd:annotation>
            <xsd:documentation>
                A type that defines a Mule-style property placeholder.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:pattern value="((\#|\!)\[.+\]|\$\{[^\}]+\})"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableClass">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:NMTOKEN-like type that also allows for Ant-style property placeholders and a leading "[".
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                    <xsd:pattern value="\[?[A-Za-z0-9_\.$]+"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="nonBlankString">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:string-like type that cannot be empty.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                    <xsd:pattern value=".*[^ ]+.*"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableName">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:NMTOKEN type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableString">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:string type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:string"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutablePortNumber">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:int type that also allows for Ant-style property placeholders and restricts the int value to a valid port number.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:int">
                    <xsd:minInclusive value="0"/>
                    <xsd:maxInclusive value="65536"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableInt">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:int type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:int"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableDecimal">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:decimal type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:decimal"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableDateTime">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:dateTime type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:dateTime"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableLong">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:long type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:long"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableBoolean">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:boolean type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:boolean"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>


    <xsd:simpleType name="expression">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:string-like type that represents a MEL expression.
                Attributes should use this type to declare that they support expressions.
                It allows property placeholders and requires the value to not be blank.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="nonBlankString"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="expressionString">
        <xsd:annotation>
            <xsd:documentation>
                An embeddable expression that outputs a String
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="expressionBoolean">
        <xsd:annotation>
            <xsd:documentation>
                A non-embeddable expression that outputs a Boolean
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="expressionInt">
        <xsd:annotation>
            <xsd:documentation>
                A non-embeddable expression that outputs an Integer
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="expressionLong">
        <xsd:annotation>
            <xsd:documentation>
                A non-embeddable expression that outputs a Long
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="expressionDouble">
        <xsd:annotation>
            <xsd:documentation>
                A non-embeddable expression that outputs a Double
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="expressionDecimal">
        <xsd:annotation>
            <xsd:documentation>
                A non-embeddable expression that outputs a Decimal
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="expressionObject">
        <xsd:annotation>
            <xsd:documentation>
                A non-embeddable expression that outputs a generic object
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="expressionList">
        <xsd:annotation>
            <xsd:documentation>
                A non-embeddable expression that outputs a Collection type
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="expressionMap">
        <xsd:annotation>
            <xsd:documentation>
                A non-embeddable expression that outputs a Map
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="expressionDateTime">
        <xsd:annotation>
            <xsd:documentation>
                A non-embeddable expression that outputs a Date
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="expression" />
    </xsd:simpleType>

    <xsd:simpleType name="timeUnitType">
        <xsd:annotation>
            <xsd:documentation>
                Supported time units enumeration
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:NMTOKEN">
            <xsd:enumeration value="MILLISECONDS"/>
            <xsd:enumeration value="SECONDS"/>
            <xsd:enumeration value="MINUTES"/>
            <xsd:enumeration value="DAYS"/>
            <xsd:enumeration value="HOURS"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!-- i found this a bit confusing, so here is some background...
         this type is typically called from something like
           <xsd:element name="properties" type="mapType/>
         and the "properties" element generates a ChildMapDefinitionParser that
         can "receive" the map entries generated by the embedded spring <entry..>
         elements and which is then set via "setProperties" on the parent.
         in other words, it's a map, and despite the name "properties" has
         nothing to do with the spring <property ...> element.
         spring elements like <entry...> are handled by
         MuleHierarchicalBeanDefinitionParserDelegate which punts them to
         the spring handler -->
    <xsd:element name="properties" type="mapType">
        <xsd:annotation>
            <xsd:documentation>
                A map of Mule properties.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="mapType">
        <xsd:complexContent>
            <xsd:extension base="spring:mapType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:group name="propertiesGroup">
        <xsd:sequence>
            <xsd:element name="property" type="keyValueType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Sets a Mule property. This is a name/value pair that can be set on components, services, etc., and which provide a generic way of configuring the system. Typically, you shouldn't need to use a generic property like this, since almost all functionality is exposed via dedicated elements. However, it can be useful in configuring obscure or overlooked options and in configuring transports from the generic endpoint elements.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="properties" minOccurs="0"/>
        </xsd:sequence>
    </xsd:group>

    <xsd:complexType name="listOrSetType">
        <xsd:complexContent>
            <xsd:extension base="spring:listOrSetType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="referenceType">
        <xsd:attribute name="ref" type="xsd:string"/>
    </xsd:complexType>

    <xsd:complexType name="keyType">
        <xsd:attribute name="key" type="xsd:string"/>
    </xsd:complexType>

    <xsd:complexType name="nameType">
        <xsd:attribute name="name" type="xsd:string"/>
    </xsd:complexType>

    <xsd:complexType name="valueType">
        <xsd:attribute name="value" type="xsd:string"/>
        <xsd:attribute name="value-ref" type="xsd:string"/>
    </xsd:complexType>

    <xsd:complexType name="keyValueType">
        <xsd:complexContent>
            <xsd:extension base="keyType">
                <xsd:attribute name="value" type="xsd:string"/>
                <xsd:attribute name="value-ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="propertyWithDataType">
        <xsd:complexContent>
            <xsd:extension base="keyType">
                <xsd:attribute name="value" type="xsd:string"/>
                <xsd:attribute name="value-ref" type="xsd:string"/>
                <xsd:attributeGroup ref="mimeTypeAttributes">
                    <xsd:annotation>
                        <xsd:documentation>
                            The mime type for the property
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attributeGroup>
                <xsd:attribute name="encoding" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            String encoding for the property.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="nameValueType">
        <xsd:complexContent>
            <xsd:extension base="nameType">
                <xsd:attribute name="value" type="xsd:string"/>
                <xsd:attribute name="value-ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="attributeType">
        <xsd:restriction base="xsd:string"/>
    </xsd:simpleType>

    <xsd:simpleType name="nonEmptyAttributeType">
        <xsd:restriction base="xsd:string">
            <xsd:minLength value="1"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!--==============================================================-->
    <!--   Connector support                                          -->
    <!--==============================================================-->

    <xsd:complexType name="connectorType">
        <xsd:complexContent>
            <xsd:extension base="abstractConnectorType">
                <xsd:sequence>
                    <!-- for normal connectors, this is for emergency use only, but it is
                         critical for custom connector -->
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element name="receiver-threading-profile" type="threadingProfileType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The threading profile to use when a connector receives messages.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="dispatcher-threading-profile" type="threadingProfileType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The threading profile to use when a connector dispatches messages.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="abstract-reconnection-strategy" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Reconnection strategy that defines how Mule should handle a connection failure.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="service-overrides" type="serviceOverridesType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Service overrides allow the connector to be further configured/customized by allowing parts of the transport implementation to be overridden, for example, the message receiver or dispatcher implementation, or the message adaptor that is used.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="dynamicNotification" type="substitutableBoolean" default="false">
                    <xsd:annotation>
                        <xsd:documentation>
                            Enables dynamic notifications for notifications fired by this connector. This allows listeners to be registered dynamically at runtime via the MuleContext, and the configured notification can be changed. This overrides the default value defined in the 'configuration' element.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="validateConnections" type="substitutableBoolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            Causes Mule to validate connections before use. Note that this is only a configuration hint,
                            transport implementations may or may not make an extra effort to validate the connection. Default is true.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="dispatcherPoolFactory-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Allows Spring beans to be defined as a dispatcher pool factory
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="serviceOverridesType">
        <xsd:attribute name="messageReceiver" type="xsd:string"/>
        <xsd:attribute name="transactedMessageReceiver" type="xsd:string"/>
        <xsd:attribute name="xaTransactedMessageReceiver" type="xsd:string"/>
        <xsd:attribute name="dispatcherFactory" type="xsd:string"/>
        <xsd:attribute name="inboundTransformer" type="xsd:string"/>
        <xsd:attribute name="outboundTransformer" type="xsd:string"/>
        <xsd:attribute name="responseTransformer" type="xsd:string"/>
        <xsd:attribute name="endpointBuilder" type="xsd:string"/>
        <xsd:attribute name="messageFactory" type="xsd:string"/>
        <xsd:attribute name="serviceFinder" type="xsd:string"/>
        <xsd:attribute name="sessionHandler" type="xsd:string"/>
        <xsd:attribute name="inboundExchangePatterns" type="xsd:string"/>
        <xsd:attribute name="outboundExchangePatterns" type="xsd:string"/>
        <xsd:attribute name="defaultExchangePattern" type="xsd:string"/>
    </xsd:complexType>

    <xsd:complexType name="transactedConnectorType">
        <xsd:complexContent>
            <xsd:extension base="connectorType">
                <xsd:attribute name="createMultipleTransactedReceivers" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            Whether to create multiple concurrent receivers for this connector. This property is used by transports that support transactions, specifically receivers that extend the TransactedPollingMessageReceiver, and provides better throughput.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="numberOfConcurrentTransactedReceivers" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            If createMultipleTransactedReceivers is set to true, the number of concurrent receivers that will be launched.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--   JNDI support                                               -->
    <!--==============================================================-->

    <xsd:complexType name="jndiConnectorType">
        <xsd:complexContent>
            <xsd:extension base="connectorType">
                <xsd:sequence>
                    <xsd:element name="jndi-provider-property" type="keyValueType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Direct setting of a JNDI property.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="jndi-provider-properties" type="mapType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Direct setting of JNDI properties (allows access to the full Spring map entry).
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="jndiContext-ref" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Set the complete context directly, via a bean reference.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="jndiInitialFactory" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>
                            The initial context factory to use. The value of the property should be the fully qualified class name of the factory class that will create an initial context.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="jndiProviderUrl" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The service provider to use. The value of the property should contain a URL string (such as "ldap://somehost:389").
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="jndiUrlPkgPrefixes" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The list of package prefixes to use when loading in URL context factories. The value of the property should be a colon-separated list of package prefixes for the class name of the factory class that will create a URL context factory.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="dataReferenceType" mixed="true">
        <xsd:attribute name="file" type="xsd:string"/>
        <xsd:attribute name="ref" type="xsd:string"/>
        <!--I don't like this flag, may be we could use content-type mappings... -->
        <xsd:attribute name="binary" type="substitutableBoolean"/>
    </xsd:complexType>

    <xsd:attributeGroup name="mimeTypeAttributes">
        <xsd:attribute name="mimeType" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The mime type, e.g. text/plain or application/json
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <!-- these cannot be references (unless we use qualified attribute names, which are ugly),
         but serve as templates to cut+paste in individual transports

    <xsd:attribute name="path" type="xsd:string">
        <xsd:annotation>
            <xsd:documentation>
                A file location.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="user" type="xsd:string">
        <xsd:annotation>
            <xsd:documentation>
                A username.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="password" type="xsd:string">
        <xsd:annotation>
            <xsd:documentation>
                A password.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="host" type="xsd:string">
        <xsd:annotation>
            <xsd:documentation>
                An IP address (eg www.mulesoft.com, localhost, 127.0.0.1).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="port" type="substitutablePortNumber">
        <xsd:annotation>
            <xsd:documentation>
                A port number.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    -->

    <!--==============================================================-->
    <!--  Cache                                                       -->
    <!--==============================================================-->

    <xsd:element name="abstract-caching-strategy" abstract="true" type="abstractCachingStrategyType"
                 substitutionGroup="abstract-extension">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for caching strategies elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="abstractCachingStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractExtensionType">
                <xsd:attribute name="name" use="optional" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the caching strategy.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
        
</xsd:schema>
