# sbm-support-rewrite
these components

The `sbm-support-rewrite` project provides Spring beans classes to parse a given project to an OpenRewrite abstract syntax tree (AST) which can then be used to run OpenRewrite recipes that were discovered on the classpath.

- `RewriteProjectParser` - parses a project to OpenRewrite's AST representation
- `RecipeDiscovery` - provides access to discovered recipes

## Getting started

### Adding the dependency
Currently only SNAPSHOT releases are available from https://repo.spring.io.
To access these, a repository must be added.

[source,xml]
.....
<repositories>
    <repository>
        <id>spring-snapshot</id>
        <url>https://repo.spring.io/snapshot</url>
        <releases>
            <enabled>false</enabled>
        </releases>
    </repository>
</repositories>
.....

Then the dependency can be retrieved.

[source,xml]
.....
<dependency>
    <groupId>org.springframwork.experimental</groupId>
    <artifactId>sbm-support-rewrite</artifactId>
    <version>0.1.0-SNAPSHOT</version>
</dependency>
.....

### Parse a project

`RewriteProjectParser` is provided as Spring bean and can be injected into components.

[source,java]
.....
@Autowired
private RewriteProjectParser parser;
.....

The provided `parse(Path)` method can be used to parse a project under a given `Path` to OpenRewrite AST.

[source,java]
.....
Path baseDir = ...
List<SourceFile> ast = parser.parse(baseDir);
.....

### ExecutionContext

OpenRewrite's `ExecutionContext` is populated during parsing and the settings can be important for recipes executed later.
The `ExecutionContext` is provided as scoped Spring bean.
It has the same scope as the parsing and a new instance is automatically created with every parse.

NOTE: The ExecutionContext should be injected and should not be created programmatically.

### Discover and run recipes

OpenRewrite recipes can be discovered from classpath with `RewriteRecipeDiscovery` which is provided as Spring bean.

[source,java]
....
@Autowired
RewriteRecipeDiscovery discovery;

@Autowired
ExecutionContext ctx;
...
Recipe recipe = discovery.getRecipe("org.openrewrite.java.spring.boot3.UpgradeSpringBoot_3_1");
RecipeRun recipe = recipe.run(new InMemoryLargeSourceSet(ast), ctx));
....


### Listen to ParserEvents

``ParserEvent``s get published during parsing.
The events can be used to provide progress information to users.
This is especially useful when parsing large projects where parsing can take some time.


* `StartedParsingProjectEvent` - Gets published when the parsing started
* `ParsedResourceEvent` - Gets published  after every parsed pom or Java file
* `SuccessfullyParsedProjectEvent` - Gets published when the parsing was successful

[source,java]
.....
@EventListener(ParsedResourceEvent.class)
public void onParsedResourceEvent(ParsedResourceEvent event) {
    Parser.Input input = event.input();
    SourceFile sourceFile = event.sourceFile();
    log("parsed %s to %s".formatted(input.getRelativePath(), sourceFile.getClass().getName()));
}
.....

## Configuration

Some behaviour can be configured through application properties or by providing custom Spring beans.

### Maven Artifact Cache
OpenRewrite uses a `MavenArtifactCache` to store downloaded jar dependencies.
The provided `MavenArtifactCache` bean tries to retrieve jars from local Maven cache `~/.m2/repository` first.
If the dependency doesn't exist it is searched under `~/.rewrite/cache/artifacts` and if it doesn't exist it is downloaded to this dir.

[source,java]
.....
@Bean
MavenArtifactCache mavenArtifactCache() {
    Path userHome = Path.of(System.getProperty("user.home"));
    Path localMavenRepo = userHome.resolve(".m2/repository");
    Path localRewriteRepo = userHome.resolve(".rewrite/cache/artifacts");
    return new LocalMavenArtifactCache(localMavenRepo)
                .orElse(localRewriteRepo));
}
.....

#### Custom Maven Artifact Cache

The provided cache configuration can be replaced with a custom bean.

[source,java]
.....
@Bean
MavenArtifactCache mavenArtifactCache() {
    return new CustomMavenArtifactCache();
}

.....




### Maven Pom Cache
OpenRewrite downloads Maven Pom files to resolve dependencies.
The pom files get cached and the cache depends on the system.

- 32-Bit systems use the `InMemoryPomCache`.
- 64-Bit systems use the `RocksdbMavenPomCache`.


#### Pom Cache Properties

|===
|Name |Description |Default Value

|`parser.isPomCacheEnabled`
|If the flag is set to false, only the default, in-memory cache is used.
|`false`

|`parser.pomCacheDirectory`
|Defines the cache dir for RocksdbMavenPomCache when `parser.isPomCacheEnabled` is `true`
|`~/.rewrite-cache`
|===

#### Custom Pom Cache
A custom `MavenPomCache` implementation can be provided through a custom Spring bean declaration.

[source,java]
.....
@Bean
public MavenPomCache mavenPomCache() {
    return new CustomMavenPomCache();
}
.....


## Example

Example code showing how to apply OpenRewrite's UpgradeSpringBoot_3_1 recipe

[source, java]
.....
import org.openrewrite.*;
import org.openrewrite.internal.InMemoryLargeSourceSet;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.core.io.Resource;
import org.springframework.sbm.parsers.ProjectScanner;
import org.springframework.sbm.parsers.RewriteMavenProjectParser;
import org.springframework.sbm.parsers.RewriteProjectParsingResult;
import org.springframework.sbm.recipes.RewriteRecipeDiscovery;

import java.nio.file.Path;
import java.util.List;
import java.util.Set;

@SpringBootApplication
public class BootUpgrade implements CommandLineRunner {
    public static void main(String[] args) {
        SpringApplication.run(BootUpgrade.class, args);
    }

    @Autowired
    ProjectScanner scanner;
    @Autowired
    RewriteMavenProjectParser parser;
    @Autowired
    RewriteRecipeDiscovery discovery;

    @Override
    public void run(String... args) throws Exception {

        String path  = "demo-spring-song-app";
        Path baseDir = Path.of(path ).toAbsolutePath().normalize();
        System.out.println(baseDir);
        if(!baseDir.toFile().exists() || !baseDir.toFile().isDirectory()) {
            throw new IllegalArgumentException("Given path '%s' does not exist or is not a directory.".formatted(path));
        }
        List<Resource> resources = scanner.scan(baseDir, Set.of("**/.idea/**", "**/.DS_Store", "**/.git/**"));
        ExecutionContext ctx = new InMemoryExecutionContext(t -> {throw new RuntimeException(t);});
        RewriteProjectParsingResult parsingResult = parser.parse(baseDir/*, resources*/, ctx);
        String recipeName = "org.openrewrite.java.spring.boot3.UpgradeSpringBoot_3_1";
        List<Recipe> recipes = discovery.discoverRecipes();
        recipes.stream()
                .filter(r -> recipeName.equals(r.getName()))
                .forEach(r -> {
                    System.out.println("Applying recipe '%s'".formatted(r.getName()));
                    LargeSourceSet lss = new InMemoryLargeSourceSet(parsingResult.sourceFiles());
                    RecipeRun recipeRun = r.run(lss, ctx);
                    recipeRun.getChangeset().getAllResults().stream()
                            .map(Result::diff)
                            .forEach(System.out::println);
                });
    }
}
.....